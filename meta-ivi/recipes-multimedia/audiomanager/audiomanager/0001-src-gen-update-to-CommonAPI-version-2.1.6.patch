From 68a1a370ac11a9fe6f8ca78a68cd09b114c287f7 Mon Sep 17 00:00:00 2001
From: Holger Behrens <holger.behrens@windriver.com>
Date: Fri, 15 Aug 2014 12:59:08 +0200
Subject: [AudioManager][PATCH] src-gen: update to CommonAPI version 2.1.6

Signed-off-by: Holger Behrens <holger.behrens@windriver.com>
---
 .../src-gen/org/genivi/NodeStateManager/Consumer.h |    8 +-
 .../genivi/NodeStateManager/ConsumerDBusProxy.cpp  |   10 +-
 .../genivi/NodeStateManager/ConsumerDBusProxy.h    |    8 +-
 .../NodeStateManager/ConsumerDBusStubAdapter.cpp   |  122 +-
 .../NodeStateManager/ConsumerDBusStubAdapter.h     |  100 +-
 .../org/genivi/NodeStateManager/ConsumerProxy.h    |   30 +-
 .../genivi/NodeStateManager/ConsumerProxyBase.h    |    8 +-
 .../org/genivi/NodeStateManager/ConsumerStub.h     |   12 +-
 .../NodeStateManager/ConsumerStubDefault.cpp       |    8 +-
 .../genivi/NodeStateManager/ConsumerStubDefault.h  |   15 +-
 .../genivi/NodeStateManager/LifeCycleConsumer.h    |    8 +-
 .../LifeCycleConsumerDBusProxy.cpp                 |   10 +-
 .../NodeStateManager/LifeCycleConsumerDBusProxy.h  |    8 +-
 .../LifeCycleConsumerDBusStubAdapter.cpp           |   36 +-
 .../LifeCycleConsumerDBusStubAdapter.h             |   34 +-
 .../NodeStateManager/LifeCycleConsumerProxy.h      |   18 +-
 .../NodeStateManager/LifeCycleConsumerProxyBase.h  |    8 +-
 .../NodeStateManager/LifeCycleConsumerStub.h       |   12 +-
 .../LifeCycleConsumerStubDefault.cpp               |    8 +-
 .../LifeCycleConsumerStubDefault.h                 |   15 +-
 AudioManagerDaemon/src-gen/org/genivi/am.cpp       |  991 ++++++++
 AudioManagerDaemon/src-gen/org/genivi/am.h         | 2445 ++++++++++++++++++++
 .../src-gen/org/genivi/am.cpp                      |    8 +-
 PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h |   53 +-
 .../src-gen/org/genivi/am/CommandControl.h         |   10 +-
 .../org/genivi/am/CommandControlDBusProxy.cpp      |   34 +-
 .../org/genivi/am/CommandControlDBusProxy.h        |   24 +-
 .../genivi/am/CommandControlDBusStubAdapter.cpp    |  194 +-
 .../org/genivi/am/CommandControlDBusStubAdapter.h  |  246 +-
 .../src-gen/org/genivi/am/CommandControlProxy.h    |   54 +-
 .../org/genivi/am/CommandControlProxyBase.h        |   24 +-
 .../src-gen/org/genivi/am/CommandControlStub.h     |   26 +-
 .../org/genivi/am/CommandControlStubDefault.cpp    |   26 +-
 .../org/genivi/am/CommandControlStubDefault.h      |   31 +-
 .../src-gen/org/genivi/am.cpp                      |    8 +-
 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h |   40 +-
 .../src-gen/org/genivi/am/RoutingControl.h         |   10 +-
 .../org/genivi/am/RoutingControlDBusProxy.cpp      |   22 +-
 .../org/genivi/am/RoutingControlDBusProxy.h        |   18 +-
 .../genivi/am/RoutingControlDBusStubAdapter.cpp    |  150 +-
 .../org/genivi/am/RoutingControlDBusStubAdapter.h  |  170 +-
 .../src-gen/org/genivi/am/RoutingControlObserver.h |   10 +-
 .../genivi/am/RoutingControlObserverDBusProxy.cpp  |   26 +-
 .../genivi/am/RoutingControlObserverDBusProxy.h    |   20 +-
 .../am/RoutingControlObserverDBusStubAdapter.cpp   |  329 +--
 .../am/RoutingControlObserverDBusStubAdapter.h     |  443 +++-
 .../org/genivi/am/RoutingControlObserverProxy.h    |   45 +-
 .../genivi/am/RoutingControlObserverProxyBase.h    |   20 +-
 .../org/genivi/am/RoutingControlObserverStub.h     |   24 +-
 .../am/RoutingControlObserverStubDefault.cpp       |   22 +-
 .../genivi/am/RoutingControlObserverStubDefault.h  |   27 +-
 .../src-gen/org/genivi/am/RoutingControlProxy.h    |   38 +-
 .../org/genivi/am/RoutingControlProxyBase.h        |   18 +-
 .../src-gen/org/genivi/am/RoutingControlStub.h     |   22 +-
 .../org/genivi/am/RoutingControlStubDefault.cpp    |   18 +-
 .../org/genivi/am/RoutingControlStubDefault.h      |   25 +-
 56 files changed, 5246 insertions(+), 903 deletions(-)
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/am.cpp
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/am.h

diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/Consumer.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/Consumer.h
index 916c744..331e957 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/Consumer.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/Consumer.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.cpp
index 6971e07..3c50296 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.cpp
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -26,7 +24,7 @@ std::shared_ptr<CommonAPI::DBus::DBusProxy> createConsumerDBusProxy(
     return std::make_shared<ConsumerDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
 }
 
-__attribute__((constructor)) void registerConsumerDBusProxy(void) {
+INITIALIZER(registerConsumerDBusProxy) {
     CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(Consumer::getInterfaceId(),
        &createConsumerDBusProxy);
 }
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.h
index 2e08248..7ed0a79 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.cpp
index 7c00c67..78f5c3c 100755
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.cpp
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include "ConsumerDBusStubAdapter.h"
 #include <org/genivi/NodeStateManager/Consumer.h>
@@ -25,7 +23,7 @@ std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createConsumerDBusStubAdapter(
     return std::make_shared<ConsumerDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
 }
 
-__attribute__((constructor)) void registerConsumerDBusStubAdapter(void) {
+INITIALIZER(registerConsumerDBusStubAdapter) {
     CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(Consumer::getInterfaceId(),
                                                                &createConsumerDBusStubAdapter);
 }
@@ -38,6 +36,7 @@ ConsumerDBusStubAdapterInternal::~ConsumerDBusStubAdapterInternal() {
 }
 
 void ConsumerDBusStubAdapterInternal::deactivateManagedInstances() {
+
 }
 
 const char* ConsumerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
@@ -131,87 +130,85 @@ const char* ConsumerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData(
     return introspectionData.c_str();
 }
 
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         ConsumerStub,
         CommonAPI::Version
-        > getConsumerInterfaceVersionStubDispatcher(&ConsumerStub::getInterfaceVersion, "uu");
+        > ConsumerDBusStubAdapterInternal::getConsumerInterfaceVersionStubDispatcher(&ConsumerStub::getInterfaceVersion, "uu");
 
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         ConsumerStub,
         int32_t
-        > getBootModeAttributeStubDispatcher(&ConsumerStub::getBootModeAttribute, "i");
-
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        > ConsumerDBusStubAdapterInternal::getBootModeAttributeStubDispatcher(&ConsumerStub::getBootModeAttribute, "i");
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         ConsumerStub,
         int32_t
-        > getRestartReasonAttributeStubDispatcher(&ConsumerStub::getRestartReasonAttribute, "i");
-
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        > ConsumerDBusStubAdapterInternal::getRestartReasonAttributeStubDispatcher(&ConsumerStub::getRestartReasonAttribute, "i");
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         ConsumerStub,
         int32_t
-        > getShutdownReasonAttributeStubDispatcher(&ConsumerStub::getShutdownReasonAttribute, "i");
-
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        > ConsumerDBusStubAdapterInternal::getShutdownReasonAttributeStubDispatcher(&ConsumerStub::getShutdownReasonAttribute, "i");
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         ConsumerStub,
         int32_t
-        > getWakeUpReasonAttributeStubDispatcher(&ConsumerStub::getWakeUpReasonAttribute, "i");
+        > ConsumerDBusStubAdapterInternal::getWakeUpReasonAttributeStubDispatcher(&ConsumerStub::getWakeUpReasonAttribute, "i");
 
 
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<>,
     std::tuple<uint32_t>
-    > getAppHealthCountStubDispatcher(&ConsumerStub::GetAppHealthCount, "u");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::getAppHealthCountStubDispatcher(&ConsumerStub::GetAppHealthCount, "u");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<uint32_t, int32_t>,
     std::tuple<int32_t>
-    > lifecycleRequestCompleteStubDispatcher(&ConsumerStub::LifecycleRequestComplete, "i");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::lifecycleRequestCompleteStubDispatcher(&ConsumerStub::LifecycleRequestComplete, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<>,
     std::tuple<uint32_t>
-    > getInterfaceVersionStubDispatcher(&ConsumerStub::GetInterfaceVersion, "u");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::getInterfaceVersionStubDispatcher(&ConsumerStub::GetInterfaceVersion, "u");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<>,
     std::tuple<int32_t, int32_t>
-    > getApplicationModeStubDispatcher(&ConsumerStub::GetApplicationMode, "ii");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::getApplicationModeStubDispatcher(&ConsumerStub::GetApplicationMode, "ii");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<std::string, std::string, int32_t>,
     std::tuple<int32_t>
-    > unRegisterSessionStubDispatcher(&ConsumerStub::UnRegisterSession, "i");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::unRegisterSessionStubDispatcher(&ConsumerStub::UnRegisterSession, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<std::string, std::string, int32_t, int32_t>,
     std::tuple<int32_t>
-    > registerSessionStubDispatcher(&ConsumerStub::RegisterSession, "i");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::registerSessionStubDispatcher(&ConsumerStub::RegisterSession, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<std::string, std::string, uint32_t>,
     std::tuple<int32_t>
-    > unRegisterShutdownClientStubDispatcher(&ConsumerStub::UnRegisterShutdownClient, "i");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::unRegisterShutdownClientStubDispatcher(&ConsumerStub::UnRegisterShutdownClient, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<std::string, std::string, uint32_t, uint32_t>,
     std::tuple<int32_t>
-    > registerShutdownClientStubDispatcher(&ConsumerStub::RegisterShutdownClient, "i");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::registerShutdownClientStubDispatcher(&ConsumerStub::RegisterShutdownClient, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<>,
     std::tuple<int32_t, int32_t>
-    > getNodeStateStubDispatcher(&ConsumerStub::GetNodeState, "ii");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::getNodeStateStubDispatcher(&ConsumerStub::GetNodeState, "ii");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<std::string, int32_t>,
     std::tuple<int32_t, int32_t>
-    > getSessionStateStubDispatcher(&ConsumerStub::GetSessionState, "ii");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > ConsumerDBusStubAdapterInternal::getSessionStateStubDispatcher(&ConsumerStub::GetSessionState, "ii");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     ConsumerStub,
     std::tuple<std::string, std::string, int32_t, int32_t>,
     std::tuple<int32_t>
-    > setSessionStateStubDispatcher(&ConsumerStub::SetSessionState, "i");
+    > ConsumerDBusStubAdapterInternal::setSessionStateStubDispatcher(&ConsumerStub::SetSessionState, "i");
+
 
 
 void ConsumerDBusStubAdapterInternal::fireNodeApplicationModeEvent(const int32_t& ApplicationModeId) {
@@ -242,10 +239,14 @@ void ConsumerDBusStubAdapterInternal::fireNodeStateEvent(const int32_t& NodeStat
         );
 }
 
+
 const ConsumerDBusStubAdapterHelper::StubDispatcherTable& ConsumerDBusStubAdapterInternal::getStubDispatcherTable() {
     return stubDispatcherTable_;
 }
 
+const CommonAPI::DBus::StubAttributeTable& ConsumerDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
 
 ConsumerDBusStubAdapterInternal::ConsumerDBusStubAdapterInternal(
         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -273,25 +274,30 @@ ConsumerDBusStubAdapterInternal::ConsumerDBusStubAdapterInternal(
             std::dynamic_pointer_cast<ConsumerStub>(stub),
             false),
         stubDispatcherTable_({
-            { { "getBootModeAttribute", "" }, &org::genivi::NodeStateManager::getBootModeAttributeStubDispatcher },
-            { { "getRestartReasonAttribute", "" }, &org::genivi::NodeStateManager::getRestartReasonAttributeStubDispatcher },
-            { { "getShutdownReasonAttribute", "" }, &org::genivi::NodeStateManager::getShutdownReasonAttributeStubDispatcher },
-            { { "getWakeUpReasonAttribute", "" }, &org::genivi::NodeStateManager::getWakeUpReasonAttributeStubDispatcher }
+            { { "getBootModeAttribute", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getBootModeAttributeStubDispatcher },
+            { { "getRestartReasonAttribute", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getRestartReasonAttributeStubDispatcher },
+            { { "getShutdownReasonAttribute", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getShutdownReasonAttributeStubDispatcher },
+            { { "getWakeUpReasonAttribute", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getWakeUpReasonAttributeStubDispatcher }
             ,
-            { { "GetAppHealthCount", "" }, &org::genivi::NodeStateManager::getAppHealthCountStubDispatcher },
-            { { "LifecycleRequestComplete", "ui" }, &org::genivi::NodeStateManager::lifecycleRequestCompleteStubDispatcher },
-            { { "GetInterfaceVersion", "" }, &org::genivi::NodeStateManager::getInterfaceVersionStubDispatcher },
-            { { "GetApplicationMode", "" }, &org::genivi::NodeStateManager::getApplicationModeStubDispatcher },
-            { { "UnRegisterSession", "ssi" }, &org::genivi::NodeStateManager::unRegisterSessionStubDispatcher },
-            { { "RegisterSession", "ssii" }, &org::genivi::NodeStateManager::registerSessionStubDispatcher },
-            { { "UnRegisterShutdownClient", "ssu" }, &org::genivi::NodeStateManager::unRegisterShutdownClientStubDispatcher },
-            { { "RegisterShutdownClient", "ssuu" }, &org::genivi::NodeStateManager::registerShutdownClientStubDispatcher },
-            { { "GetNodeState", "" }, &org::genivi::NodeStateManager::getNodeStateStubDispatcher },
-            { { "GetSessionState", "si" }, &org::genivi::NodeStateManager::getSessionStateStubDispatcher },
-            { { "SetSessionState", "ssii" }, &org::genivi::NodeStateManager::setSessionStateStubDispatcher }
-            }) {
+            { { "GetAppHealthCount", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getAppHealthCountStubDispatcher },
+            { { "LifecycleRequestComplete", "ui" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::lifecycleRequestCompleteStubDispatcher },
+            { { "GetInterfaceVersion", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getInterfaceVersionStubDispatcher },
+            { { "GetApplicationMode", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getApplicationModeStubDispatcher },
+            { { "UnRegisterSession", "ssi" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::unRegisterSessionStubDispatcher },
+            { { "RegisterSession", "ssii" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::registerSessionStubDispatcher },
+            { { "UnRegisterShutdownClient", "ssu" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::unRegisterShutdownClientStubDispatcher },
+            { { "RegisterShutdownClient", "ssuu" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::registerShutdownClientStubDispatcher },
+            { { "GetNodeState", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getNodeStateStubDispatcher },
+            { { "GetSessionState", "si" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getSessionStateStubDispatcher },
+            { { "SetSessionState", "ssii" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::setSessionStateStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getConsumerInterfaceVersionStubDispatcher });
+}
 
-    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::NodeStateManager::getConsumerInterfaceVersionStubDispatcher });
+const bool ConsumerDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
 }
 
 } // namespace NodeStateManager
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.h
index d8335d7..9f154fe 100755
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -32,7 +30,7 @@ namespace NodeStateManager {
 
 typedef CommonAPI::DBus::DBusStubAdapterHelper<ConsumerStub> ConsumerDBusStubAdapterHelper;
 
-class ConsumerDBusStubAdapterInternal: public ConsumerStubAdapter, public ConsumerDBusStubAdapterHelper {
+class ConsumerDBusStubAdapterInternal: public virtual ConsumerStubAdapter, public ConsumerDBusStubAdapterHelper {
  public:
     ConsumerDBusStubAdapterInternal(
             const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -45,6 +43,8 @@ class ConsumerDBusStubAdapterInternal: public ConsumerStubAdapter, public Consum
 
     ~ConsumerDBusStubAdapterInternal();
 
+    virtual const bool hasFreedesktopProperties();
+
 
     void fireNodeApplicationModeEvent(const int32_t& ApplicationModeId);
     void fireSessionStateChangedEvent(const std::string& SessionStateName, const int32_t& SeatID, const int32_t& SessionState);
@@ -52,15 +52,99 @@ class ConsumerDBusStubAdapterInternal: public ConsumerStubAdapter, public Consum
 
 
     const ConsumerDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
 
     void deactivateManagedInstances();
 
 
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        CommonAPI::Version
+        > getConsumerInterfaceVersionStubDispatcher;
+
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > getBootModeAttributeStubDispatcher;
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > getRestartReasonAttributeStubDispatcher;
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > getShutdownReasonAttributeStubDispatcher;
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > getWakeUpReasonAttributeStubDispatcher;
+
+
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<uint32_t>
+    > getAppHealthCountStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<uint32_t, int32_t>,
+    std::tuple<int32_t>
+    > lifecycleRequestCompleteStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<uint32_t>
+    > getInterfaceVersionStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<int32_t, int32_t>
+    > getApplicationModeStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t>,
+    std::tuple<int32_t>
+    > unRegisterSessionStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t, int32_t>,
+    std::tuple<int32_t>
+    > registerSessionStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, uint32_t>,
+    std::tuple<int32_t>
+    > unRegisterShutdownClientStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, uint32_t, uint32_t>,
+    std::tuple<int32_t>
+    > registerShutdownClientStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<int32_t, int32_t>
+    > getNodeStateStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, int32_t>,
+    std::tuple<int32_t, int32_t>
+    > getSessionStateStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t, int32_t>,
+    std::tuple<int32_t>
+    > setSessionStateStubDispatcher;
+
+
+
+
  protected:
     virtual const char* getMethodsDBusIntrospectionXmlData() const;
-    
-  private:
+
+ private:
     ConsumerDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
 };
 
 class ConsumerDBusStubAdapter: public ConsumerDBusStubAdapterInternal, public std::enable_shared_from_this<ConsumerDBusStubAdapter> {
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxy.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxy.h
index bd473f1..7fff5d7 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxy.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -358,6 +356,12 @@ public:
     std::shared_ptr<ConsumerProxyBase> delegate_;
 };
 
+#ifdef WIN32
+    typedef ConsumerProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> ConsumerProxyDefault;
+#else
+    typedef ConsumerProxy<> ConsumerProxyDefault;
+#endif
+
 namespace ConsumerExtensions {
     template <template <typename > class _ExtensionType>
     class BootModeAttributeExtension {
@@ -366,6 +370,9 @@ namespace ConsumerExtensions {
     
         static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConsumerProxyBase::BootModeAttribute>, extension_type>::value,
                       "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        BootModeAttributeExtension() {}
+    #endif
     
         BootModeAttributeExtension(ConsumerProxyBase& proxy): attributeExtension_(proxy.getBootModeAttribute()) {
         }
@@ -385,6 +392,9 @@ namespace ConsumerExtensions {
     
         static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConsumerProxyBase::RestartReasonAttribute>, extension_type>::value,
                       "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        RestartReasonAttributeExtension() {}
+    #endif
     
         RestartReasonAttributeExtension(ConsumerProxyBase& proxy): attributeExtension_(proxy.getRestartReasonAttribute()) {
         }
@@ -404,6 +414,9 @@ namespace ConsumerExtensions {
     
         static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConsumerProxyBase::ShutdownReasonAttribute>, extension_type>::value,
                       "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        ShutdownReasonAttributeExtension() {}
+    #endif
     
         ShutdownReasonAttributeExtension(ConsumerProxyBase& proxy): attributeExtension_(proxy.getShutdownReasonAttribute()) {
         }
@@ -423,6 +436,9 @@ namespace ConsumerExtensions {
     
         static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConsumerProxyBase::WakeUpReasonAttribute>, extension_type>::value,
                       "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        WakeUpReasonAttributeExtension() {}
+    #endif
     
         WakeUpReasonAttributeExtension(ConsumerProxyBase& proxy): attributeExtension_(proxy.getWakeUpReasonAttribute()) {
         }
@@ -442,8 +458,8 @@ namespace ConsumerExtensions {
 //
 template <typename ... _AttributeExtensions>
 ConsumerProxy<_AttributeExtensions...>::ConsumerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
-        delegate_(std::dynamic_pointer_cast<ConsumerProxyBase>(delegate)),
-        _AttributeExtensions(*(std::dynamic_pointer_cast<ConsumerProxyBase>(delegate)))... {
+        _AttributeExtensions(*(std::dynamic_pointer_cast<ConsumerProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<ConsumerProxyBase>(delegate)) {
 }
 
 template <typename ... _AttributeExtensions>
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxyBase.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxyBase.h
index a5d9ed8..b1ed2c7 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxyBase.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxyBase.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStub.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStub.h
index c56949a..cec15a4 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStub.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStub.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -97,7 +95,7 @@ class ConsumerStubRemoteEvent {
  * This class and the one above are the ones an application developer needs to have
  * a look at if he wants to implement a service.
  */
-class ConsumerStub : public virtual CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent> {
+class ConsumerStub: public virtual CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent> {
 public:
     virtual ~ConsumerStub() { }
     virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
@@ -143,6 +141,8 @@ public:
     using CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent>::initStubAdapter;
     typedef CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent>::StubAdapterType StubAdapterType;
     typedef CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef ConsumerStubRemoteEvent RemoteEventType;
+    typedef Consumer StubInterface;
 };
 
 } // namespace NodeStateManager
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.cpp
index 1e34da5..ae9df6d 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.cpp
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include <org/genivi/NodeStateManager/ConsumerStubDefault.h>
 
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.h
index 80dc926..a202e01 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -100,8 +98,7 @@ protected:
     virtual bool validateShutdownReasonAttributeRequestedValue(const int32_t& value);
     virtual bool trySetWakeUpReasonAttribute(int32_t value);
     virtual bool validateWakeUpReasonAttributeRequestedValue(const int32_t& value);
-private:
-    class RemoteEventHandler: public ConsumerStubRemoteEvent {
+    class RemoteEventHandler: public virtual ConsumerStubRemoteEvent {
      public:
         RemoteEventHandler(ConsumerStubDefault* defaultStub);
 
@@ -113,8 +110,8 @@ private:
      private:
         ConsumerStubDefault* defaultStub_;
     };
-
-    RemoteEventHandler remoteEventHandler_;
+private:
+    ConsumerStubDefault::RemoteEventHandler remoteEventHandler_;
 
     int32_t bootModeAttributeValue_;
     int32_t restartReasonAttributeValue_;
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumer.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumer.h
index 56cbf4c..4324f5a 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumer.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumer.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.cpp
index ab06c26..9342ce1 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.cpp
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -26,7 +24,7 @@ std::shared_ptr<CommonAPI::DBus::DBusProxy> createLifeCycleConsumerDBusProxy(
     return std::make_shared<LifeCycleConsumerDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
 }
 
-__attribute__((constructor)) void registerLifeCycleConsumerDBusProxy(void) {
+INITIALIZER(registerLifeCycleConsumerDBusProxy) {
     CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(LifeCycleConsumer::getInterfaceId(),
        &createLifeCycleConsumerDBusProxy);
 }
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.h
index d69d805..99142ee 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.cpp
index 96ac35b..c35cb3d 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.cpp
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include "LifeCycleConsumerDBusStubAdapter.h"
 #include <org/genivi/NodeStateManager/LifeCycleConsumer.h>
@@ -25,7 +23,7 @@ std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createLifeCycleConsumerDBusStu
     return std::make_shared<LifeCycleConsumerDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
 }
 
-__attribute__((constructor)) void registerLifeCycleConsumerDBusStubAdapter(void) {
+INITIALIZER(registerLifeCycleConsumerDBusStubAdapter) {
     CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(LifeCycleConsumer::getInterfaceId(),
                                                                &createLifeCycleConsumerDBusStubAdapter);
 }
@@ -38,6 +36,7 @@ LifeCycleConsumerDBusStubAdapterInternal::~LifeCycleConsumerDBusStubAdapterInter
 }
 
 void LifeCycleConsumerDBusStubAdapterInternal::deactivateManagedInstances() {
+
 }
 
 const char* LifeCycleConsumerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
@@ -55,17 +54,20 @@ const char* LifeCycleConsumerDBusStubAdapterInternal::getMethodsDBusIntrospectio
     return introspectionData.c_str();
 }
 
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         LifeCycleConsumerStub,
         CommonAPI::Version
-        > getLifeCycleConsumerInterfaceVersionStubDispatcher(&LifeCycleConsumerStub::getInterfaceVersion, "uu");
+        > LifeCycleConsumerDBusStubAdapterInternal::getLifeCycleConsumerInterfaceVersionStubDispatcher(&LifeCycleConsumerStub::getInterfaceVersion, "uu");
+
 
 
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     LifeCycleConsumerStub,
     std::tuple<uint32_t, uint32_t>,
     std::tuple<int32_t>
-    > lifecycleRequestStubDispatcher(&LifeCycleConsumerStub::LifecycleRequest, "i");
+    > LifeCycleConsumerDBusStubAdapterInternal::lifecycleRequestStubDispatcher(&LifeCycleConsumerStub::LifecycleRequest, "i");
+
+
 
 
 
@@ -73,6 +75,9 @@ const LifeCycleConsumerDBusStubAdapterHelper::StubDispatcherTable& LifeCycleCons
     return stubDispatcherTable_;
 }
 
+const CommonAPI::DBus::StubAttributeTable& LifeCycleConsumerDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
 
 LifeCycleConsumerDBusStubAdapterInternal::LifeCycleConsumerDBusStubAdapterInternal(
         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -100,10 +105,15 @@ LifeCycleConsumerDBusStubAdapterInternal::LifeCycleConsumerDBusStubAdapterIntern
             std::dynamic_pointer_cast<LifeCycleConsumerStub>(stub),
             false),
         stubDispatcherTable_({
-            { { "LifecycleRequest", "uu" }, &org::genivi::NodeStateManager::lifecycleRequestStubDispatcher }
-            }) {
+            { { "LifecycleRequest", "uu" }, &org::genivi::NodeStateManager::LifeCycleConsumerDBusStubAdapterInternal::lifecycleRequestStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::NodeStateManager::LifeCycleConsumerDBusStubAdapterInternal::getLifeCycleConsumerInterfaceVersionStubDispatcher });
+}
 
-    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::NodeStateManager::getLifeCycleConsumerInterfaceVersionStubDispatcher });
+const bool LifeCycleConsumerDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
 }
 
 } // namespace NodeStateManager
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.h
index c03f0c3..f07c508 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -32,7 +30,7 @@ namespace NodeStateManager {
 
 typedef CommonAPI::DBus::DBusStubAdapterHelper<LifeCycleConsumerStub> LifeCycleConsumerDBusStubAdapterHelper;
 
-class LifeCycleConsumerDBusStubAdapterInternal: public LifeCycleConsumerStubAdapter, public LifeCycleConsumerDBusStubAdapterHelper {
+class LifeCycleConsumerDBusStubAdapterInternal: public virtual LifeCycleConsumerStubAdapter, public LifeCycleConsumerDBusStubAdapterHelper {
  public:
     LifeCycleConsumerDBusStubAdapterInternal(
             const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -45,19 +43,39 @@ class LifeCycleConsumerDBusStubAdapterInternal: public LifeCycleConsumerStubAdap
 
     ~LifeCycleConsumerDBusStubAdapterInternal();
 
+    virtual const bool hasFreedesktopProperties();
+
 
 
 
     const LifeCycleConsumerDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
 
     void deactivateManagedInstances();
 
 
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        LifeCycleConsumerStub,
+        CommonAPI::Version
+        > getLifeCycleConsumerInterfaceVersionStubDispatcher;
+
+
+
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    LifeCycleConsumerStub,
+    std::tuple<uint32_t, uint32_t>,
+    std::tuple<int32_t>
+    > lifecycleRequestStubDispatcher;
+
+
+
+
  protected:
     virtual const char* getMethodsDBusIntrospectionXmlData() const;
-    
-  private:
+
+ private:
     LifeCycleConsumerDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
 };
 
 class LifeCycleConsumerDBusStubAdapter: public LifeCycleConsumerDBusStubAdapterInternal, public std::enable_shared_from_this<LifeCycleConsumerDBusStubAdapter> {
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxy.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxy.h
index 374ef1e..36da1a7 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxy.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -108,14 +106,20 @@ public:
     std::shared_ptr<LifeCycleConsumerProxyBase> delegate_;
 };
 
+#ifdef WIN32
+    typedef LifeCycleConsumerProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> LifeCycleConsumerProxyDefault;
+#else
+    typedef LifeCycleConsumerProxy<> LifeCycleConsumerProxyDefault;
+#endif
+
 
 //
 // LifeCycleConsumerProxy Implementation
 //
 template <typename ... _AttributeExtensions>
 LifeCycleConsumerProxy<_AttributeExtensions...>::LifeCycleConsumerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
-        delegate_(std::dynamic_pointer_cast<LifeCycleConsumerProxyBase>(delegate)),
-        _AttributeExtensions(*(std::dynamic_pointer_cast<LifeCycleConsumerProxyBase>(delegate)))... {
+        _AttributeExtensions(*(std::dynamic_pointer_cast<LifeCycleConsumerProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<LifeCycleConsumerProxyBase>(delegate)) {
 }
 
 template <typename ... _AttributeExtensions>
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h
index ad8ee6a..c9d727d 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStub.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStub.h
index 58f5bb0..20116b6 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStub.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStub.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -77,7 +75,7 @@ class LifeCycleConsumerStubRemoteEvent {
  * This class and the one above are the ones an application developer needs to have
  * a look at if he wants to implement a service.
  */
-class LifeCycleConsumerStub : public virtual CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent> {
+class LifeCycleConsumerStub: public virtual CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent> {
 public:
     virtual ~LifeCycleConsumerStub() { }
     virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
@@ -89,6 +87,8 @@ public:
     using CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent>::initStubAdapter;
     typedef CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent>::StubAdapterType StubAdapterType;
     typedef CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef LifeCycleConsumerStubRemoteEvent RemoteEventType;
+    typedef LifeCycleConsumer StubInterface;
 };
 
 } // namespace NodeStateManager
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.cpp
index 03801fa..f91ebc4 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.cpp
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include <org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h>
 
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h
index fe35b9f..8b2e805 100644
--- a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -47,8 +45,7 @@ public:
 
 
 protected:
-private:
-    class RemoteEventHandler: public LifeCycleConsumerStubRemoteEvent {
+    class RemoteEventHandler: public virtual LifeCycleConsumerStubRemoteEvent {
      public:
         RemoteEventHandler(LifeCycleConsumerStubDefault* defaultStub);
 
@@ -56,8 +53,8 @@ private:
      private:
         LifeCycleConsumerStubDefault* defaultStub_;
     };
-
-    RemoteEventHandler remoteEventHandler_;
+private:
+    LifeCycleConsumerStubDefault::RemoteEventHandler remoteEventHandler_;
 
 
     CommonAPI::Version interfaceVersion_;
diff --git a/AudioManagerDaemon/src-gen/org/genivi/am.cpp b/AudioManagerDaemon/src-gen/org/genivi/am.cpp
new file mode 100644
index 0000000..152c8b6
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/am.cpp
@@ -0,0 +1,991 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#include "am.h"
+
+
+namespace org {
+namespace genivi {
+namespace am {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+am_Route_s::am_Route_s(const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_RoutingElement_L& routeValue):
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        route(routeValue)
+{
+}
+
+
+bool operator==(const am_Route_s& lhs, const am_Route_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.route == rhs.route
+    ;
+}
+
+void am_Route_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> route;
+}
+
+void am_Route_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << route;
+}
+
+am_Availability_s::am_Availability_s(const am_Availability_e& availabilityValue, const am_CustomAvailabilityReason_t& availabilityReasonValue):
+        availability(availabilityValue),
+        availabilityReason(availabilityReasonValue)
+{
+}
+
+
+bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.availability == rhs.availability &&
+        lhs.availabilityReason == rhs.availabilityReason
+    ;
+}
+
+void am_Availability_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> availability;
+    inputStream >> availabilityReason;
+}
+
+void am_Availability_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << availability;
+    outputStream << availabilityReason;
+}
+
+am_ClassProperty_s::am_ClassProperty_s(const am_CustomClassProperty_t& classPropertyValue, const int16_t& valueValue):
+        classProperty(classPropertyValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.classProperty == rhs.classProperty &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_ClassProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> classProperty;
+    inputStream >> value;
+}
+
+void am_ClassProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << classProperty;
+    outputStream << value;
+}
+
+am_Crossfader_s::am_Crossfader_s(const am_crossfaderID_t& crossfaderIDValue, const std::string& nameValue, const am_sinkID_t& sinkID_AValue, const am_sinkID_t& sinkID_BValue, const am_sourceID_t& sourceIDValue, const am_HotSink_e& hotSinkValue):
+        crossfaderID(crossfaderIDValue),
+        name(nameValue),
+        sinkID_A(sinkID_AValue),
+        sinkID_B(sinkID_BValue),
+        sourceID(sourceIDValue),
+        hotSink(hotSinkValue)
+{
+}
+
+
+bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.crossfaderID == rhs.crossfaderID &&
+        lhs.name == rhs.name &&
+        lhs.sinkID_A == rhs.sinkID_A &&
+        lhs.sinkID_B == rhs.sinkID_B &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.hotSink == rhs.hotSink
+    ;
+}
+
+void am_Crossfader_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> crossfaderID;
+    inputStream >> name;
+    inputStream >> sinkID_A;
+    inputStream >> sinkID_B;
+    inputStream >> sourceID;
+    inputStream >> hotSink;
+}
+
+void am_Crossfader_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << crossfaderID;
+    outputStream << name;
+    outputStream << sinkID_A;
+    outputStream << sinkID_B;
+    outputStream << sourceID;
+    outputStream << hotSink;
+}
+
+am_Gateway_s::am_Gateway_s(const am_gatewayID_t& gatewayIDValue, const std::string& nameValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_domainID_t& domainSinkIDValue, const am_domainID_t& domainSourceIDValue, const am_domainID_t& controlDomainIDValue, const am_ConnectionFormat_L& listSourceFormatsValue, const am_ConnectionFormat_L& listSinkFormatsValue, const am_Convertion_L& convertionMatrixValue):
+        gatewayID(gatewayIDValue),
+        name(nameValue),
+        sinkID(sinkIDValue),
+        sourceID(sourceIDValue),
+        domainSinkID(domainSinkIDValue),
+        domainSourceID(domainSourceIDValue),
+        controlDomainID(controlDomainIDValue),
+        listSourceFormats(listSourceFormatsValue),
+        listSinkFormats(listSinkFormatsValue),
+        convertionMatrix(convertionMatrixValue)
+{
+}
+
+
+bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.gatewayID == rhs.gatewayID &&
+        lhs.name == rhs.name &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.domainSinkID == rhs.domainSinkID &&
+        lhs.domainSourceID == rhs.domainSourceID &&
+        lhs.controlDomainID == rhs.controlDomainID &&
+        lhs.listSourceFormats == rhs.listSourceFormats &&
+        lhs.listSinkFormats == rhs.listSinkFormats &&
+        lhs.convertionMatrix == rhs.convertionMatrix
+    ;
+}
+
+void am_Gateway_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> gatewayID;
+    inputStream >> name;
+    inputStream >> sinkID;
+    inputStream >> sourceID;
+    inputStream >> domainSinkID;
+    inputStream >> domainSourceID;
+    inputStream >> controlDomainID;
+    inputStream >> listSourceFormats;
+    inputStream >> listSinkFormats;
+    inputStream >> convertionMatrix;
+}
+
+void am_Gateway_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << gatewayID;
+    outputStream << name;
+    outputStream << sinkID;
+    outputStream << sourceID;
+    outputStream << domainSinkID;
+    outputStream << domainSourceID;
+    outputStream << controlDomainID;
+    outputStream << listSourceFormats;
+    outputStream << listSinkFormats;
+    outputStream << convertionMatrix;
+}
+
+am_RoutingElement_s::am_RoutingElement_s(const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_domainID_t& domainIDValue, const am_CustomConnectionFormat_t& connectionFormatValue):
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        domainID(domainIDValue),
+        connectionFormat(connectionFormatValue)
+{
+}
+
+
+bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.domainID == rhs.domainID &&
+        lhs.connectionFormat == rhs.connectionFormat
+    ;
+}
+
+void am_RoutingElement_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> domainID;
+    inputStream >> connectionFormat;
+}
+
+void am_RoutingElement_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << domainID;
+    outputStream << connectionFormat;
+}
+
+am_SoundProperty_s::am_SoundProperty_s(const am_CustomSoundPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_SoundProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_SoundProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_SystemProperty_s::am_SystemProperty_s(const am_CustomSystemPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_SystemProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_SystemProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_SinkClass_s::am_SinkClass_s(const am_sinkClass_t& sinkClassIDValue, const std::string& nameValue, const am_ClassProperty_L& listClassPropertiesValue):
+        sinkClassID(sinkClassIDValue),
+        name(nameValue),
+        listClassProperties(listClassPropertiesValue)
+{
+}
+
+
+bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkClassID == rhs.sinkClassID &&
+        lhs.name == rhs.name &&
+        lhs.listClassProperties == rhs.listClassProperties
+    ;
+}
+
+void am_SinkClass_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkClassID;
+    inputStream >> name;
+    inputStream >> listClassProperties;
+}
+
+void am_SinkClass_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkClassID;
+    outputStream << name;
+    outputStream << listClassProperties;
+}
+
+am_SourceClass_s::am_SourceClass_s(const am_sourceClass_t& sourceClassIDValue, const std::string& nameValue, const am_ClassProperty_L& listClassPropertiesValue):
+        sourceClassID(sourceClassIDValue),
+        name(nameValue),
+        listClassProperties(listClassPropertiesValue)
+{
+}
+
+
+bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceClassID == rhs.sourceClassID &&
+        lhs.name == rhs.name &&
+        lhs.listClassProperties == rhs.listClassProperties
+    ;
+}
+
+void am_SourceClass_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceClassID;
+    inputStream >> name;
+    inputStream >> listClassProperties;
+}
+
+void am_SourceClass_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceClassID;
+    outputStream << name;
+    outputStream << listClassProperties;
+}
+
+am_SourceType_s::am_SourceType_s(const am_sourceID_t& sourceIDValue, const std::string& nameValue, const am_Availability_s& availabilityValue, const am_sourceClass_t& sourceClassIDValue):
+        sourceID(sourceIDValue),
+        name(nameValue),
+        availability(availabilityValue),
+        sourceClassID(sourceClassIDValue)
+{
+}
+
+
+bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.name == rhs.name &&
+        lhs.availability == rhs.availability &&
+        lhs.sourceClassID == rhs.sourceClassID
+    ;
+}
+
+void am_SourceType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> name;
+    inputStream >> availability;
+    inputStream >> sourceClassID;
+}
+
+void am_SourceType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << name;
+    outputStream << availability;
+    outputStream << sourceClassID;
+}
+
+am_SinkType_s::am_SinkType_s(const am_sinkID_t& sinkIDValue, const std::string& nameValue, const am_Availability_s& availabilityValue, const am_mainVolume_t& volumeValue, const am_MuteState_e& muteStateValue, const am_sinkClass_t& sinkClassIDValue):
+        sinkID(sinkIDValue),
+        name(nameValue),
+        availability(availabilityValue),
+        volume(volumeValue),
+        muteState(muteStateValue),
+        sinkClassID(sinkClassIDValue)
+{
+}
+
+
+bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkID == rhs.sinkID &&
+        lhs.name == rhs.name &&
+        lhs.availability == rhs.availability &&
+        lhs.volume == rhs.volume &&
+        lhs.muteState == rhs.muteState &&
+        lhs.sinkClassID == rhs.sinkClassID
+    ;
+}
+
+void am_SinkType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkID;
+    inputStream >> name;
+    inputStream >> availability;
+    inputStream >> volume;
+    inputStream >> muteState;
+    inputStream >> sinkClassID;
+}
+
+void am_SinkType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkID;
+    outputStream << name;
+    outputStream << availability;
+    outputStream << volume;
+    outputStream << muteState;
+    outputStream << sinkClassID;
+}
+
+am_Handle_s::am_Handle_s(const am_Handle_e& handleTypeValue, const uint16_t& handleValue):
+        handleType(handleTypeValue),
+        handle(handleValue)
+{
+}
+
+
+bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.handleType == rhs.handleType &&
+        lhs.handle == rhs.handle
+    ;
+}
+
+void am_Handle_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> handleType;
+    inputStream >> handle;
+}
+
+void am_Handle_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << handleType;
+    outputStream << handle;
+}
+
+am_MainSoundProperty_s::am_MainSoundProperty_s(const am_CustomMainSoundPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_MainSoundProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_MainSoundProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_MainConnectionType_s::am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionIDValue, const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_timeSync_t& delayValue, const am_ConnectionState_e& connectionStateValue):
+        mainConnectionID(mainConnectionIDValue),
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        delay(delayValue),
+        connectionState(connectionStateValue)
+{
+}
+
+
+bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.mainConnectionID == rhs.mainConnectionID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.delay == rhs.delay &&
+        lhs.connectionState == rhs.connectionState
+    ;
+}
+
+void am_MainConnectionType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> mainConnectionID;
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> delay;
+    inputStream >> connectionState;
+}
+
+void am_MainConnectionType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << mainConnectionID;
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << delay;
+    outputStream << connectionState;
+}
+
+am_MainConnection_s::am_MainConnection_s(const am_mainConnectionID_t& mainConnectionIDValue, const am_ConnectionState_e& connectionStateValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_timeSync_t& delayValue, const am_ConnectionID_L& listConnectionIDValue):
+        mainConnectionID(mainConnectionIDValue),
+        connectionState(connectionStateValue),
+        sinkID(sinkIDValue),
+        sourceID(sourceIDValue),
+        delay(delayValue),
+        listConnectionID(listConnectionIDValue)
+{
+}
+
+
+bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.mainConnectionID == rhs.mainConnectionID &&
+        lhs.connectionState == rhs.connectionState &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.delay == rhs.delay &&
+        lhs.listConnectionID == rhs.listConnectionID
+    ;
+}
+
+void am_MainConnection_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> mainConnectionID;
+    inputStream >> connectionState;
+    inputStream >> sinkID;
+    inputStream >> sourceID;
+    inputStream >> delay;
+    inputStream >> listConnectionID;
+}
+
+void am_MainConnection_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << mainConnectionID;
+    outputStream << connectionState;
+    outputStream << sinkID;
+    outputStream << sourceID;
+    outputStream << delay;
+    outputStream << listConnectionID;
+}
+
+am_NotificationPayload_s::am_NotificationPayload_s(const am_CustomNotificationType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_NotificationPayload_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_NotificationPayload_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_NotificationConfiguration_s::am_NotificationConfiguration_s(const am_CustomNotificationType_t& typeValue, const am_NotificationStatus_e& statusValue, const int16_t& parameterValue):
+        type(typeValue),
+        status(statusValue),
+        parameter(parameterValue)
+{
+}
+
+
+bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.status == rhs.status &&
+        lhs.parameter == rhs.parameter
+    ;
+}
+
+void am_NotificationConfiguration_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> status;
+    inputStream >> parameter;
+}
+
+void am_NotificationConfiguration_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << status;
+    outputStream << parameter;
+}
+
+am_Sink_s::am_Sink_s(const am_sinkID_t& sinkIDValue, const std::string& nameValue, const am_domainID_t& domainIDValue, const am_sinkClass_t& sinkClassIDValue, const am_volume_t& volumeValue, const bool& visibleValue, const am_Availability_s& availableValue, const am_MuteState_e& muteStateValue, const am_mainVolume_t& mainVolumeValue, const am_SoundProperty_L& listSoundPropertiesValue, const am_ConnectionFormat_L& listConnectionFormatsValue, const am_MainSoundProperty_L& listMainSoundPropertiesValue, const am_NotificationConfiguration_L& listMainNotificationConfigurationsValue, const am_NotificationConfiguration_L& listNotificationConfigurationsValue):
+        sinkID(sinkIDValue),
+        name(nameValue),
+        domainID(domainIDValue),
+        sinkClassID(sinkClassIDValue),
+        volume(volumeValue),
+        visible(visibleValue),
+        available(availableValue),
+        muteState(muteStateValue),
+        mainVolume(mainVolumeValue),
+        listSoundProperties(listSoundPropertiesValue),
+        listConnectionFormats(listConnectionFormatsValue),
+        listMainSoundProperties(listMainSoundPropertiesValue),
+        listMainNotificationConfigurations(listMainNotificationConfigurationsValue),
+        listNotificationConfigurations(listNotificationConfigurationsValue)
+{
+}
+
+
+bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkID == rhs.sinkID &&
+        lhs.name == rhs.name &&
+        lhs.domainID == rhs.domainID &&
+        lhs.sinkClassID == rhs.sinkClassID &&
+        lhs.volume == rhs.volume &&
+        lhs.visible == rhs.visible &&
+        lhs.available == rhs.available &&
+        lhs.muteState == rhs.muteState &&
+        lhs.mainVolume == rhs.mainVolume &&
+        lhs.listSoundProperties == rhs.listSoundProperties &&
+        lhs.listConnectionFormats == rhs.listConnectionFormats &&
+        lhs.listMainSoundProperties == rhs.listMainSoundProperties &&
+        lhs.listMainNotificationConfigurations == rhs.listMainNotificationConfigurations &&
+        lhs.listNotificationConfigurations == rhs.listNotificationConfigurations
+    ;
+}
+
+void am_Sink_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkID;
+    inputStream >> name;
+    inputStream >> domainID;
+    inputStream >> sinkClassID;
+    inputStream >> volume;
+    inputStream >> visible;
+    inputStream >> available;
+    inputStream >> muteState;
+    inputStream >> mainVolume;
+    inputStream >> listSoundProperties;
+    inputStream >> listConnectionFormats;
+    inputStream >> listMainSoundProperties;
+    inputStream >> listMainNotificationConfigurations;
+    inputStream >> listNotificationConfigurations;
+}
+
+void am_Sink_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkID;
+    outputStream << name;
+    outputStream << domainID;
+    outputStream << sinkClassID;
+    outputStream << volume;
+    outputStream << visible;
+    outputStream << available;
+    outputStream << muteState;
+    outputStream << mainVolume;
+    outputStream << listSoundProperties;
+    outputStream << listConnectionFormats;
+    outputStream << listMainSoundProperties;
+    outputStream << listMainNotificationConfigurations;
+    outputStream << listNotificationConfigurations;
+}
+
+am_Source_s::am_Source_s(const am_sourceID_t& sourceIDValue, const am_domainID_t& domainIDValue, const std::string& nameValue, const am_sourceClass_t& sourceClassIDValue, const am_SourceState_e& sourceStateValue, const am_volume_t& volumeValue, const bool& visibleValue, const am_Availability_s& availableValue, const am_InterruptState_e& interruptStateValue, const am_SoundProperty_L& listSoundPropertiesValue, const am_ConnectionFormat_L& listConnectionFormatsValue, const am_MainSoundProperty_L& listMainSoundPropertiesValue, const am_NotificationConfiguration_L& listMainNotificationConfigurationsValue, const am_NotificationConfiguration_L& listNotificationConfigurationsValue):
+        sourceID(sourceIDValue),
+        domainID(domainIDValue),
+        name(nameValue),
+        sourceClassID(sourceClassIDValue),
+        sourceState(sourceStateValue),
+        volume(volumeValue),
+        visible(visibleValue),
+        available(availableValue),
+        interruptState(interruptStateValue),
+        listSoundProperties(listSoundPropertiesValue),
+        listConnectionFormats(listConnectionFormatsValue),
+        listMainSoundProperties(listMainSoundPropertiesValue),
+        listMainNotificationConfigurations(listMainNotificationConfigurationsValue),
+        listNotificationConfigurations(listNotificationConfigurationsValue)
+{
+}
+
+
+bool operator==(const am_Source_s& lhs, const am_Source_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.domainID == rhs.domainID &&
+        lhs.name == rhs.name &&
+        lhs.sourceClassID == rhs.sourceClassID &&
+        lhs.sourceState == rhs.sourceState &&
+        lhs.volume == rhs.volume &&
+        lhs.visible == rhs.visible &&
+        lhs.available == rhs.available &&
+        lhs.interruptState == rhs.interruptState &&
+        lhs.listSoundProperties == rhs.listSoundProperties &&
+        lhs.listConnectionFormats == rhs.listConnectionFormats &&
+        lhs.listMainSoundProperties == rhs.listMainSoundProperties &&
+        lhs.listMainNotificationConfigurations == rhs.listMainNotificationConfigurations &&
+        lhs.listNotificationConfigurations == rhs.listNotificationConfigurations
+    ;
+}
+
+void am_Source_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> domainID;
+    inputStream >> name;
+    inputStream >> sourceClassID;
+    inputStream >> sourceState;
+    inputStream >> volume;
+    inputStream >> visible;
+    inputStream >> available;
+    inputStream >> interruptState;
+    inputStream >> listSoundProperties;
+    inputStream >> listConnectionFormats;
+    inputStream >> listMainSoundProperties;
+    inputStream >> listMainNotificationConfigurations;
+    inputStream >> listNotificationConfigurations;
+}
+
+void am_Source_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << domainID;
+    outputStream << name;
+    outputStream << sourceClassID;
+    outputStream << sourceState;
+    outputStream << volume;
+    outputStream << visible;
+    outputStream << available;
+    outputStream << interruptState;
+    outputStream << listSoundProperties;
+    outputStream << listConnectionFormats;
+    outputStream << listMainSoundProperties;
+    outputStream << listMainNotificationConfigurations;
+    outputStream << listNotificationConfigurations;
+}
+
+am_Domain_s::am_Domain_s(const am_domainID_t& domainIDValue, const std::string& nameValue, const std::string& busnameValue, const std::string& nodenameValue, const bool& earlyValue, const bool& completeValue, const am_DomainState_e& stateValue):
+        domainID(domainIDValue),
+        name(nameValue),
+        busname(busnameValue),
+        nodename(nodenameValue),
+        early(earlyValue),
+        complete(completeValue),
+        state(stateValue)
+{
+}
+
+
+bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.domainID == rhs.domainID &&
+        lhs.name == rhs.name &&
+        lhs.busname == rhs.busname &&
+        lhs.nodename == rhs.nodename &&
+        lhs.early == rhs.early &&
+        lhs.complete == rhs.complete &&
+        lhs.state == rhs.state
+    ;
+}
+
+void am_Domain_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> domainID;
+    inputStream >> name;
+    inputStream >> busname;
+    inputStream >> nodename;
+    inputStream >> early;
+    inputStream >> complete;
+    inputStream >> state;
+}
+
+void am_Domain_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << domainID;
+    outputStream << name;
+    outputStream << busname;
+    outputStream << nodename;
+    outputStream << early;
+    outputStream << complete;
+    outputStream << state;
+}
+
+am_EarlyData_s::am_EarlyData_s(const am_EarlyDataType_e& typeValue, const am_DataType_u& sinksourceValue, const am_EarlyData_u& dataValue):
+        type(typeValue),
+        sinksource(sinksourceValue),
+        data(dataValue)
+{
+}
+
+
+bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.sinksource == rhs.sinksource &&
+        lhs.data == rhs.data
+    ;
+}
+
+void am_EarlyData_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> sinksource;
+    inputStream >> data;
+}
+
+void am_EarlyData_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << sinksource;
+    outputStream << data;
+}
+
+am_Connection_s::am_Connection_s(const am_connectionID_t& connectionIDValue, const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_timeSync_t& delayValue, const am_CustomConnectionFormat_t& connectionFormatValue):
+        connectionID(connectionIDValue),
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        delay(delayValue),
+        connectionFormat(connectionFormatValue)
+{
+}
+
+
+bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.connectionID == rhs.connectionID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.delay == rhs.delay &&
+        lhs.connectionFormat == rhs.connectionFormat
+    ;
+}
+
+void am_Connection_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> connectionID;
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> delay;
+    inputStream >> connectionFormat;
+}
+
+void am_Connection_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << connectionID;
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << delay;
+    outputStream << connectionFormat;
+}
+
+am_Volumes_s::am_Volumes_s(const am_VolumeType_e& volumeTypeValue, const am_DataType_u& volumeIDValue, const am_volume_t& volumeValue, const am_CustomRampType_t& rampValue, const am_time_t& timeValue):
+        volumeType(volumeTypeValue),
+        volumeID(volumeIDValue),
+        volume(volumeValue),
+        ramp(rampValue),
+        time(timeValue)
+{
+}
+
+
+bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.volumeType == rhs.volumeType &&
+        lhs.volumeID == rhs.volumeID &&
+        lhs.volume == rhs.volume &&
+        lhs.ramp == rhs.ramp &&
+        lhs.time == rhs.time
+    ;
+}
+
+void am_Volumes_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> volumeType;
+    inputStream >> volumeID;
+    inputStream >> volume;
+    inputStream >> ramp;
+    inputStream >> time;
+}
+
+void am_Volumes_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << volumeType;
+    outputStream << volumeID;
+    outputStream << volume;
+    outputStream << ramp;
+    outputStream << time;
+}
+
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/AudioManagerDaemon/src-gen/org/genivi/am.h b/AudioManagerDaemon/src-gen/org/genivi/am.h
new file mode 100644
index 0000000..dced63c
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/am.h
@@ -0,0 +1,2445 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_am_H_
+#define ORG_GENIVI_am_H_
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <CommonAPI/SerializableVariant.h>
+#include <CommonAPI/types.h>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <vector>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+
+namespace am {
+    /**
+     * a source ID
+     */
+    /**
+     * a source ID
+     */
+    typedef uint16_t am_sourceID_t;
+    /**
+     * a mainConnection ID
+     */
+    /**
+     * a mainConnection ID
+     */
+    typedef uint16_t am_mainConnectionID_t;
+    /**
+     * offset time that is introduced in milli seconds.
+     */
+    /**
+     * offset time that is introduced in milli seconds.
+     */
+    typedef int16_t am_timeSync_t;
+    /**
+     * a sink ID
+     */
+    /**
+     * a sink ID
+     */
+    typedef uint16_t am_sinkID_t;
+    /**
+     * represents the connection state
+     */
+    enum class am_ConnectionState_e: int32_t {
+        CS_UNKNOWN = 0,
+        /**
+         * This means the connection is just building up
+         */
+        CS_CONNECTING = 1,
+        /**
+         * the connection is ready to be used
+         */
+        CS_CONNECTED = 2,
+        /**
+         * the connection is in the course to be knocked down
+         */
+        CS_DISCONNECTING = 3,
+        /**
+         * only relevant for connectionStatechanged. Is send after the connection was
+         *  removed
+         */
+        CS_DISCONNECTED = 4,
+        /**
+         * this means the connection is still build up but unused at the moment
+         */
+        CS_SUSPENDED = 5,
+        CS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_ConnectionState_eComparator;
+    /**
+     * this type holds all information of connections relevant to the HMI
+     */
+    /**
+     * this type holds all information of connections relevant to the HMI
+     */
+    struct am_MainConnectionType_s: CommonAPI::SerializableStruct {
+        /**
+         * the ID of the mainconnection
+         */
+         am_mainConnectionID_t mainConnectionID;
+        /**
+         * the sourceID where the connection starts
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID where the connection ends
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the delay of the mainconnection
+         */
+         am_timeSync_t delay;
+        /**
+         * the current connection state
+         */
+         am_ConnectionState_e connectionState;
+    
+        am_MainConnectionType_s() = default;
+        am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_ConnectionState_e& connectionState);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    typedef std::vector<am_MainConnectionType_s> am_MainConnection_L;
+    /**
+     * product specific identifier of property
+     */
+    /**
+     * product specific identifier of property
+     */
+    typedef uint16_t am_CustomClassProperty_t;
+    /**
+     * describes class properties
+     */
+    /**
+     * describes class properties
+     */
+    struct am_ClassProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the property as enum
+         */
+         am_CustomClassProperty_t classProperty;
+        /**
+         * the value of the property
+         */
+         int16_t value;
+    
+        am_ClassProperty_s() = default;
+        am_ClassProperty_s(const am_CustomClassProperty_t& classProperty, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_ClassProperty_s> am_ClassProperty_L;
+    typedef uint16_t am_sinkClass_t;
+    /**
+     * struct describing sinkclasses
+     */
+    /**
+     * struct describing sinkclasses
+     */
+    struct am_SinkClass_s: CommonAPI::SerializableStruct {
+        /**
+         * the ID of the sinkClass
+         */
+         am_sinkClass_t sinkClassID;
+        /**
+         * the name of the sinkClass - must be unique in the system
+         */
+         std::string name;
+        /**
+         * the list of the class properties. These are pairs of  a project specific enum
+         *  describing the type of the value and an integer holding the real value.
+         */
+         am_ClassProperty_L listClassProperties;
+    
+        am_SinkClass_s() = default;
+        am_SinkClass_s(const am_sinkClass_t& sinkClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    typedef std::vector<am_SinkClass_s> am_SinkClass_L;
+    /**
+     * This is the volume presented on the command interface. It is in the duty of the
+     *  Controller to change the volumes given here into meaningful values on the
+     *  routing interface.
+    The range of this type is customer specific.
+     */
+    /**
+     * This is the volume presented on the command interface. It is in the duty of the
+     *  Controller to change the volumes given here into meaningful values on the
+     *  routing interface.
+    The range of this type is customer specific.
+     */
+    typedef int16_t am_mainVolume_t;
+    /**
+     * This  project specific value gives the information about reason for reason for
+     *  Source/Sink change
+     */
+    /**
+     * This  project specific value gives the information about reason for reason for
+     *  Source/Sink change
+     */
+    typedef uint16_t am_CustomAvailabilityReason_t;
+    /**
+     * with the help of this enum, sinks and sources can report their availability
+     *  state
+     */
+    enum class am_Availability_e: int32_t {
+        /**
+         * default
+         */
+        A_UNKNOWN = 0,
+        /**
+         * The source / sink is available
+         */
+        A_AVAILABLE = 1,
+        /**
+         * the source / sink is not available
+         */
+        A_UNAVAILABLE = 2,
+        A_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Availability_eComparator;
+    enum class am_MuteState_e: int32_t {
+        /**
+         * default
+         */
+        MS_UNKNOWN = 0,
+        /**
+         * the source / sink is muted
+         */
+        MS_MUTED = 1,
+        /**
+         * the source / sink is unmuted
+         */
+        MS_UNMUTED = 2,
+        MS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_MuteState_eComparator;
+    /**
+     * this describes the availability of a sink or a source together with the latest
+     *  change
+     */
+    /**
+     * this describes the availability of a sink or a source together with the latest
+     *  change
+     */
+    struct am_Availability_s: CommonAPI::SerializableStruct {
+        /**
+         * the current availability state
+         */
+         am_Availability_e availability;
+        /**
+         * the reason for the last change. This can be used to trigger events that deal
+         *  with state changes.
+         */
+         am_CustomAvailabilityReason_t availabilityReason;
+    
+        am_Availability_s() = default;
+        am_Availability_s(const am_Availability_e& availability, const am_CustomAvailabilityReason_t& availabilityReason);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    /**
+     * this type holds all information of sinks relevant to the HMI
+     */
+    /**
+     * this type holds all information of sinks relevant to the HMI
+     */
+    struct am_SinkType_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the sink, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The name of the sink. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * This attribute reflects the availability of the sink. There are several reasons
+         *  why a sink could be not available for the moment: for example the shutdown of
+         *  a sink because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two pieces of information:
+        
+            Availablility: the
+         *  status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s availability;
+        /**
+         * This is the representation of the Volume for the commandInterface. It is used
+         *  by the HMI to set the volume of a sink, the AudioManagerController has to
+         *  transform this into real source and sink volumes.
+         */
+         am_mainVolume_t volume;
+         am_MuteState_e muteState;
+        /**
+         * The sinkClassID references to a sinkClass. With the help of classification,
+         *  rules can be setup to define the system behaviour.
+         */
+         am_sinkClass_t sinkClassID;
+    
+        am_SinkType_s() = default;
+        am_SinkType_s(const am_sinkID_t& sinkID, const std::string& name, const am_Availability_s& availability, const am_mainVolume_t& volume, const am_MuteState_e& muteState, const am_sinkClass_t& sinkClassID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_SinkType_s> am_SinkType_L;
+    typedef uint16_t am_sourceClass_t;
+    /**
+     * struct describing source classes
+     */
+    /**
+     * struct describing source classes
+     */
+    struct am_SourceClass_s: CommonAPI::SerializableStruct {
+        /**
+         * the source ID
+         */
+         am_sourceClass_t sourceClassID;
+        /**
+         * the name of the sourceClass - must be unique in the system
+         */
+         std::string name;
+        /**
+         * the list of the class properties. These are pairs of  a project specific enum
+         *  describing the type of the value and an integer holding the real value.
+         */
+         am_ClassProperty_L listClassProperties;
+    
+        am_SourceClass_s() = default;
+        am_SourceClass_s(const am_sourceClass_t& sourceClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    typedef std::vector<am_SourceClass_s> am_SourceClass_L;
+    /**
+     * this type holds all information of sources relevant to the HMI
+     */
+    /**
+     * this type holds all information of sources relevant to the HMI
+     */
+    struct am_SourceType_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the source, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The name of the source. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * the availability of the source
+         */
+         am_Availability_s availability;
+        /**
+         * the sourceClassID, indicates the class the source is in. This information can
+         *  be used by the Controller to implement different behaviour for different
+         *  classes.
+         */
+         am_sourceClass_t sourceClassID;
+    
+        am_SourceType_s() = default;
+        am_SourceType_s(const am_sourceID_t& sourceID, const std::string& name, const am_Availability_s& availability, const am_sourceClass_t& sourceClassID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_SourceType_s> am_SourceType_L;
+    /**
+     * describes the different system properties. Project specific
+     */
+    /**
+     * describes the different system properties. Project specific
+     */
+    typedef uint16_t am_CustomSystemPropertyType_t;
+    /**
+     * struct describing system properties
+     */
+    /**
+     * struct describing system properties
+     */
+    struct am_SystemProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type that is set
+         */
+         am_CustomSystemPropertyType_t type;
+        /**
+         * the value
+         */
+         int16_t value;
+    
+        am_SystemProperty_s() = default;
+        am_SystemProperty_s(const am_CustomSystemPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_SystemProperty_s> am_SystemProperty_L;
+    /**
+     * a connection ID
+     */
+    /**
+     * a connection ID
+     */
+    typedef uint16_t am_connectionID_t;
+    typedef std::vector<am_connectionID_t> am_ConnectionID_L;
+    /**
+     * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and
+     *  maximum can be limited by actual project.
+     */
+    /**
+     * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and
+     *  maximum can be limited by actual project.
+     */
+    typedef int16_t am_volume_t;
+    /**
+     * Project specific sound properties.
+     */
+    /**
+     * Project specific sound properties.
+     */
+    typedef uint16_t am_CustomSoundPropertyType_t;
+    /**
+     * This enum characterizes the data of the EarlyData_t
+     */
+    enum class am_EarlyDataType_e: int32_t {
+        /**
+         * default
+         */
+        ES_UNKNOWN = 0,
+        /**
+         * the source volume
+         */
+        ED_SOURCE_VOLUME = 1,
+        /**
+         * the sink volume
+         */
+        ED_SINK_VOLUME = 2,
+        /**
+         * a source property
+         */
+        ED_SOURCE_PROPERTY = 3,
+        /**
+         * a sink property
+         */
+        ED_SINK_PROPERTY = 4,
+        ED_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_EarlyDataType_eComparator;
+    /**
+     * struct describing the sound property
+     */
+    /**
+     * struct describing the sound property
+     */
+    struct am_SoundProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type of the property - a project specific enum
+         */
+         am_CustomSoundPropertyType_t type;
+        /**
+         * the actual value of the property
+         */
+         int16_t value;
+    
+        am_SoundProperty_s() = default;
+        am_SoundProperty_s(const am_CustomSoundPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    /**
+     * data type depends of am_EarlyDataType_e:
+    volume_t in case of ED_SOURCE_VOLUME,
+     *  ED_SINK_VOLUME 
+    soundProperty_t in case of ED_SOURCE_PROPERTY,
+     *  ED_SINK_PROPERTY
+     */
+    /**
+     * data type depends of am_EarlyDataType_e:
+    volume_t in case of ED_SOURCE_VOLUME,
+     *  ED_SINK_VOLUME 
+    soundProperty_t in case of ED_SOURCE_PROPERTY,
+     *  ED_SINK_PROPERTY
+     */
+    typedef CommonAPI::Variant<am_volume_t, am_SoundProperty_s>  am_EarlyData_u;
+    /**
+     * data type depends of am_EarlyDataType_e:
+    sourceID in case of ED_SOURCE_VOLUME,
+     *  ED_SOURCE_PROPERTY
+    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
+     */
+    /**
+     * data type depends of am_EarlyDataType_e:
+    sourceID in case of ED_SOURCE_VOLUME,
+     *  ED_SOURCE_PROPERTY
+    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
+     */
+    typedef CommonAPI::Variant<am_sinkID_t, am_sourceID_t>  am_DataType_u;
+    struct am_EarlyData_s: CommonAPI::SerializableStruct {
+         am_EarlyDataType_e type;
+         am_DataType_u sinksource;
+         am_EarlyData_u data;
+    
+        am_EarlyData_s() = default;
+        am_EarlyData_s(const am_EarlyDataType_e& type, const am_DataType_u& sinksource, const am_EarlyData_u& data);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeVariantType();
+            typeOutputStream.writeVariantType();
+        }
+    };
+    typedef std::vector<am_EarlyData_s> am_EarlyData_L;
+    /**
+     * Here are all SoundProperties that can be set via the CommandInterface. Product
+     *  specific
+     */
+    /**
+     * Here are all SoundProperties that can be set via the CommandInterface. Product
+     *  specific
+     */
+    typedef uint16_t am_CustomMainSoundPropertyType_t;
+    /**
+     * struct describung mainsound property
+     */
+    /**
+     * struct describung mainsound property
+     */
+    struct am_MainSoundProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type of the property
+         */
+         am_CustomMainSoundPropertyType_t type;
+        /**
+         * the actual value
+         */
+         int16_t value;
+    
+        am_MainSoundProperty_s() = default;
+        am_MainSoundProperty_s(const am_CustomMainSoundPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_MainSoundProperty_s> am_MainSoundProperty_L;
+    /**
+     * gives the type of the Notification.
+     */
+    /**
+     * gives the type of the Notification.
+     */
+    typedef uint16_t am_CustomNotificationType_t;
+    enum class am_NotificationStatus_e: int32_t {
+        NS_UNKNOWN = 0,
+        /**
+         * No notification, the function is turned off
+         */
+        NS_OFF = 1,
+        /**
+         * Periodic notifications are sent out. The period in ms is given by
+         *  am_NotificationParameter
+         */
+        NS_PERIODIC = 2,
+        /**
+         * The notification is sent out when the minimum given by am_NotificationParameter
+         *  is reached.
+         */
+        NS_MINIMUM = 3,
+        /**
+         * The notification is sent out when the maximum given by am_NotificationParameter
+         *  is reached.
+         */
+        NS_MAXIMUM = 4,
+        /**
+         * The notification is sent out when a change happened. The Resolution of the
+         *  change is defined by am_NotificationParameter.
+         */
+        NS_CHANGE_ = 5,
+        NS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_NotificationStatus_eComparator;
+    /**
+     * This struct holds information about the configuration for notifications
+     */
+    /**
+     * This struct holds information about the configuration for notifications
+     */
+    struct am_NotificationConfiguration_s: CommonAPI::SerializableStruct {
+        /**
+         * The notification type of the notification
+         */
+         am_CustomNotificationType_t type;
+        /**
+         * The Notification status. This can be periodic, min/max value based or even off
+         *  for example
+         */
+         am_NotificationStatus_e status;
+        /**
+         * This gives additional information to the notification status. 
+        Relation between
+         *  notification status and the value:
+        NS_PERIODIC - the period in ms
+        NS_MINIMUM
+         *  - the minimum value that triggers the notification
+        NS_MAXIMUM - the maximum
+         *  value that triggers the notifcation
+        NS_CHANGE - the resolution of the change
+         *  value
+         */
+         int16_t parameter;
+    
+        am_NotificationConfiguration_s() = default;
+        am_NotificationConfiguration_s(const am_CustomNotificationType_t& type, const am_NotificationStatus_e& status, const int16_t& parameter);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_NotificationConfiguration_s> am_NotificationConfiguration_L;
+    /**
+     * a domain ID
+     */
+    /**
+     * a domain ID
+     */
+    typedef uint16_t am_domainID_t;
+    /**
+     * This project specific value classifies the format in which data is exchanged
+     *  within a connection.
+     */
+    /**
+     * This project specific value classifies the format in which data is exchanged
+     *  within a connection.
+     */
+    typedef uint16_t am_CustomConnectionFormat_t;
+    /**
+     * This represents one "hopp" in a route
+     */
+    /**
+     * This represents one "hopp" in a route
+     */
+    struct am_RoutingElement_s: CommonAPI::SerializableStruct {
+        /**
+         * the source ID
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the domainID the routeElement is in
+         */
+         am_domainID_t domainID;
+        /**
+         * the connectionformat that is used for the route
+         */
+         am_CustomConnectionFormat_t connectionFormat;
+    
+        am_RoutingElement_s() = default;
+        am_RoutingElement_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_domainID_t& domainID, const am_CustomConnectionFormat_t& connectionFormat);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_RoutingElement_s> am_RoutingElement_L;
+    typedef std::vector<am_SoundProperty_s> am_SoundProperty_L;
+    /**
+     * time in ms!
+     */
+    /**
+     * time in ms!
+     */
+    typedef int16_t am_time_t;
+    /**
+     * For products, different ramp types can be defined here.
+    It is in the
+     *  responsibility of the product to make sure that the routing plugins are aware
+     *  of the ramp types used.
+     */
+    /**
+     * For products, different ramp types can be defined here.
+    It is in the
+     *  responsibility of the product to make sure that the routing plugins are aware
+     *  of the ramp types used.
+     */
+    typedef uint16_t am_CustomRampType_t;
+    /**
+     * This datatype determines if a sourceID or a sinkID is used in the union
+     *  following
+     */
+    enum class am_VolumeType_e: int32_t {
+        VT_UNKNOWN = 0,
+        /**
+         * the following type is a sink
+         */
+        VT_SINK = 1,
+        /**
+         * the following type is a source
+         */
+        VT_SOURCE = 2,
+        VT_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_VolumeType_eComparator;
+    /**
+     * This types describe a mixed description for source and sinks volumes.
+     */
+    /**
+     * This types describe a mixed description for source and sinks volumes.
+     */
+    struct am_Volumes_s: CommonAPI::SerializableStruct {
+        /**
+         * describes the type of the volume: source or sink.
+         */
+         am_VolumeType_e volumeType;
+        /**
+         * either sourceID or sinkID
+         */
+         am_DataType_u volumeID;
+        /**
+         * The volume
+         */
+         am_volume_t volume;
+        /**
+         * the ramp that shall be driven
+         */
+         am_CustomRampType_t ramp;
+        /**
+         * the time for the ramp
+         */
+         am_time_t time;
+    
+        am_Volumes_s() = default;
+        am_Volumes_s(const am_VolumeType_e& volumeType, const am_DataType_u& volumeID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeVariantType();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_Volumes_s> am_Volumes_L;
+    typedef std::vector<am_CustomConnectionFormat_t> am_ConnectionFormat_L;
+    typedef bool am_bool_t;
+    typedef std::vector<am_bool_t> am_Convertion_L;
+    /**
+     * a gateway ID
+     */
+    /**
+     * a gateway ID
+     */
+    typedef uint16_t am_gatewayID_t;
+    /**
+     * a crossfader ID
+     */
+    /**
+     * a crossfader ID
+     */
+    typedef uint16_t am_crossfaderID_t;
+    /**
+     * speed
+     */
+    /**
+     * speed
+     */
+    typedef uint16_t am_speed_t;
+    /**
+     * describes the active sink of a crossfader.
+     */
+    enum class am_HotSink_e: int32_t {
+        /**
+         * default
+         */
+        HS_UNKNOWN = 0,
+        /**
+         * sinkA is active
+         */
+        HS_SINKA = 1,
+        /**
+         * sinkB is active
+         */
+        HS_SINKB = 2,
+        /**
+         * the crossfader is in the transition state
+         */
+        HS_INTERMEDIATE = 3,
+        HS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_HotSink_eComparator;
+    enum class am_DomainState_e: int32_t {
+        /**
+         * default
+         */
+        DS_UNKNOWN = 0,
+        /**
+         * the domain is controlled by the daemon
+         */
+        DS_CONTROLLED = 1,
+        /**
+         * the domain is independent starting up
+         */
+        DS_INDEPENDENT_STARTUP = 1,
+        /**
+         * the domain is independent running down
+         */
+        DS_INDEPENDENT_RUNDOWN = 2,
+        DS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_DomainState_eComparator;
+    /**
+     * the errors of the audiomanager. All possible errors are in here. This enum is
+     *  used widely as return parameter.
+     */
+    enum class am_Error_e: int32_t {
+        /**
+         * no error - positive reply
+         */
+        E_OK = 0,
+        /**
+         * default
+         */
+        E_UNKNOWN = 1,
+        /**
+         * value out of range
+         */
+        E_OUT_OF_RANGE = 2,
+        /**
+         * not used
+         */
+        E_NOT_USED = 3,
+        /**
+         * a database error occurred
+         */
+        E_DATABASE_ERROR = 4,
+        /**
+         * the desired object already exists
+         */
+        E_ALREADY_EXISTS = 5,
+        /**
+         * there is no change
+         */
+        E_NO_CHANGE = 6,
+        /**
+         * the desired action is not possible
+         */
+        E_NOT_POSSIBLE = 7,
+        /**
+         * the desired object is non existent
+         */
+        E_NON_EXISTENT = 8,
+        /**
+         * the asynchronous action was aborted
+         */
+        E_ABORTED = 9,
+        /**
+         * This error is returned in case a connect is issued with a connectionFormat that
+         *  cannot be selected for the connection. This could be either due to the
+         *  capabilities of a source or a sink or gateway compatibilities for example
+         */
+        E_WRONG_FORMAT = 10,
+        E_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Error_eComparator;
+    enum class am_InterruptState_e: int32_t {
+        /**
+         * default
+         */
+        IS_UNKNOWN = 0,
+        /**
+         * the interrupt state is off - no interrupt
+         */
+        IS_OFF = 1,
+        /**
+         * the interrupt state is interrupted - the interrupt is active
+         */
+        IS_INTERRUPTED = 2,
+        IS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_InterruptState_eComparator;
+    /**
+     * This enumeration is used to define the type of the action that is correlated to
+     *  a handle.
+     */
+    enum class am_Handle_e: int32_t {
+        H_UNKNOWN = 0,
+        H_CONNECT = 1,
+        H_DISCONNECT = 2,
+        H_SETSOURCESTATE = 3,
+        H_SETSINKVOLUME = 4,
+        H_SETSOURCEVOLUME = 5,
+        H_SETSINKSOUNDPROPERTY = 6,
+        H_SETSOURCESOUNDPROPERTY = 7,
+        H_SETSINKSOUNDPROPERTIES = 8,
+        H_SETSOURCESOUNDPROPERTIES = 9,
+        H_CROSSFADE = 10,
+        H_SETVOLUMES = 11,
+        H_SETSINKNOTIFICATION = 12,
+        H_SETSOURCENOTIFICATION = 13,
+        H_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Handle_eComparator;
+    /**
+     * The source state reflects the state of the source
+     */
+    enum class am_SourceState_e: int32_t {
+        SS_UNKNNOWN = 0,
+        /**
+         * The source can be activly heared
+         */
+        SS_ON = 1,
+        /**
+         * The source cannot be heared
+         */
+        SS_OFF = 2,
+        /**
+         * The source is paused. Meaning it cannot be heared but should be prepared to
+         *  play again soon.
+         */
+        SS_PAUSED = 3,
+        SS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_SourceState_eComparator;
+    /**
+     * This enum describes the ready state of the routing part
+     */
+    enum class am_RoutingReady_e: int32_t {
+        RR_UNKNOWN = 0,
+        RR_READY = 1,
+        RR_RUNDOWN = 2
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_RoutingReady_eComparator;
+    /**
+     * a list of routing elements that lead from source to sink
+     */
+    /**
+     * a list of routing elements that lead from source to sink
+     */
+    struct am_Route_s: CommonAPI::SerializableStruct {
+        /**
+         * the sourceID where the route starts
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID where the route ends
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the actual route as list of routing elements
+         */
+         am_RoutingElement_L route;
+    
+        am_Route_s() = default;
+        am_Route_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_RoutingElement_L& route);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a crossfader.
+     */
+    /**
+     * This struct describes the attribiutes of a crossfader.
+     */
+    struct am_Crossfader_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the crossfader, it is unique in the system. There are 2 ways,
+         *  ID can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManager daemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_crossfaderID_t crossfaderID;
+        /**
+         * The name of the crossfader. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The sinkID of the SinkA. Sinks shall be registered before registering the
+         *  crossfader.
+         */
+         am_sinkID_t sinkID_A;
+        /**
+         * The sinkID of the SinkB. Sinks shall be registered before registering the
+         *  crossfader.
+         */
+         am_sinkID_t sinkID_B;
+        /**
+         * The sourceID of the crossfader source. The source shall be registered before
+         *  the crossfader.
+         */
+         am_sourceID_t sourceID;
+        /**
+         * This enum can have 3 states:
+        
+            HS_SINKA sinkA is the current hot one, sinkB
+         *  is not audible
+            HS_SINKB sinkB is the current hot one, sinkB is not
+         *  audible
+            HS_INTERMEDIATE the fader is stuck in between a cross-fading
+         *  action. This could be due to an abort or an error. Before using the
+         *  crossfader, it must be set to either HS_SINKA or HS_SINKB.
+         */
+         am_HotSink_e hotSink;
+    
+        am_Crossfader_s() = default;
+        am_Crossfader_s(const am_crossfaderID_t& crossfaderID, const std::string& name, const am_sinkID_t& sinkID_A, const am_sinkID_t& sinkID_B, const am_sourceID_t& sourceID, const am_HotSink_e& hotSink);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    struct am_Gateway_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the gateway, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_gatewayID_t gatewayID;
+        /**
+         * The name of the gateway. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The sinkID of the gateway sink-end. The sink is a full blown sink with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sinks of
+         *  a gateway as non-visible. Care needs to be taken that the connectionsFormats
+         *  match with the ones in the conversionMatrix. If the sink is located in the
+         *  controllingDomain, the ID needs to be retrieved by registering the sink before
+         *  registering the gateway. In case the sink is in a different domain, the ID
+         *  needs to be retrieved via peeking.
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The sourceID of the gateway sink-end. The sink is a full blown source with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sources
+         *  of a gateway as non-visible. Care needs to be taken that the
+         *  connectionsFormats match with the ones in the conversionMatrix. If the source
+         *  is located in the controllingDomain, the ID needs to be retrieved by
+         *  registering the source before registering the gateway. In case the source is
+         *  in a different domain, the ID needs to be retrieved via peeking.
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The ID of the sink. If the domain is the same like the controlling domain, the
+         *  ID is known due to registration. If the domain is different, the ID needs to
+         *  be retrieved via peeking.
+         */
+         am_domainID_t domainSinkID;
+        /**
+         * The ID of the source. If the domain is the same like the controlling domain,
+         *  the ID is known due to registration. If the domain is different, the ID needs
+         *  to be retrieved via peeking.
+         */
+         am_domainID_t domainSourceID;
+        /**
+         * This is the ID of the domain that registers the gateway.
+         */
+         am_domainID_t controlDomainID;
+        /**
+         * This is the list of available formats on the source side of the gateway. It is
+         *  not defined during the gateway registration but copied from the source
+         *  registration.
+         */
+         am_ConnectionFormat_L listSourceFormats;
+        /**
+         * This is the list of available formats on the sink side of the gateway. It is
+         *  not defined during the gateway registration but copied from the sink
+         *  registration.
+         */
+         am_ConnectionFormat_L listSinkFormats;
+        /**
+         * This is matrix holding information about the conversion capability of the
+         *  gateway, it's length is defined by the length(listSinkFormats) x
+         *  length(listSourceFormats).
+        If a SinkFormat can be converted into a
+         *  SourceFormat, the vector will hold a 1, if no conversion is possible, a
+         *  0.
+        The data is stored row orientated, where the rows are related to the
+         *  sinksFormats and the columns to the sourceFormats. The first value will hold
+         *  the conversion information from the first sourceFormat to the first sinkFormat
+         *  for example and the seventh value the information about the 3rd sinkFormat to
+         *  the 1st sourceFormat in case we would have 3 sourceFormats.
+         */
+         am_Convertion_L convertionMatrix;
+    
+        am_Gateway_s() = default;
+        am_Gateway_s(const am_gatewayID_t& gatewayID, const std::string& name, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_domainID_t& domainSinkID, const am_domainID_t& domainSourceID, const am_domainID_t& controlDomainID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * a handle is used for asynchronous operations and is uniquely assigned for each
+     *  of this operations
+     */
+    /**
+     * a handle is used for asynchronous operations and is uniquely assigned for each
+     *  of this operations
+     */
+    struct am_Handle_s: CommonAPI::SerializableStruct {
+        /**
+         * the handletype
+         */
+         am_Handle_e handleType;
+        /**
+         * the handle as value
+         */
+         uint16_t handle;
+    
+        am_Handle_s() = default;
+        am_Handle_s(const am_Handle_e& handleType, const uint16_t& handle);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    /**
+     * struct that holds attribiutes of a mainconnection
+     */
+    /**
+     * struct that holds attribiutes of a mainconnection
+     */
+    struct am_MainConnection_s: CommonAPI::SerializableStruct {
+        /**
+         * the assigned ID
+         */
+         am_mainConnectionID_t mainConnectionID;
+        /**
+         * the current connection state
+         */
+         am_ConnectionState_e connectionState;
+        /**
+         * the sinkID
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the sourceID
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the delay of the connection
+         */
+         am_timeSync_t delay;
+        /**
+         * the list of sub connection IDs the mainconnection consists of
+         */
+         am_ConnectionID_L listConnectionID;
+    
+        am_MainConnection_s() = default;
+        am_MainConnection_s(const am_mainConnectionID_t& mainConnectionID, const am_ConnectionState_e& connectionState, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_timeSync_t& delay, const am_ConnectionID_L& listConnectionID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct holds the payload of a notification.
+     */
+    /**
+     * This struct holds the payload of a notification.
+     */
+    struct am_NotificationPayload_s: CommonAPI::SerializableStruct {
+        /**
+         * This defines the notification type
+         */
+         am_CustomNotificationType_t type;
+        /**
+         * This is finally the value of the notification. It's meaning depends on the
+         *  notificationType
+         */
+         int16_t value;
+    
+        am_NotificationPayload_s() = default;
+        am_NotificationPayload_s(const am_CustomNotificationType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a sink
+     */
+    /**
+     * This struct describes the attribiutes of a sink
+     */
+    struct am_Sink_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the sink, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The name of the sink. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The domainID is the domain the sink belongs to. A sink can only be in one
+         *  domain.
+         */
+         am_domainID_t domainID;
+        /**
+         * The sinkClassID references to a sinkClass. With the help of classification,
+         *  rules can be setup to define the system behaviour.
+         */
+         am_sinkClass_t sinkClassID;
+        /**
+         * This is the volume of the sink. It is set by the AudioManagerController.
+         */
+         am_volume_t volume;
+        /**
+         * This Boolean flag indicates whether a sink is visible to the commandInterface
+         *  or not. If the User must have the possibility to choose the source in the HMI,
+         *  it must be visible. But there are also good reasons for invisible sinks, for
+         *  example if the sink is part of a crossfader or gateway. HMI relevant changes
+         *  in visible sinks will be automatically reported by the daemon to the
+         *  commandInterface.
+         */
+         bool visible;
+        /**
+         * This attribute reflects the availability of the sink. There are several reasons
+         *  why a sink could be not available for the moment: for example the shutdown of
+         *  a sink because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two pieces of information:
+        
+            Availablility: the
+         *  status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s available;
+        /**
+         * This attribute reflects the muteState of the sink. The information is not the
+         *  "real" state of the sink, but the HMI representation for he commandInterface
+         *  controlled by the AudioManagerController.
+         */
+         am_MuteState_e muteState;
+        /**
+         * This is the representation of the Volume for the commandInterface. It is used
+         *  by the HMI to set the volume of a sink, the AudioManagerController has to
+         *  transform this into real source and sink volumes.
+         */
+         am_mainVolume_t mainVolume;
+        /**
+         * This is the list of soundProperties, that the sink is capable of. The
+         *  soundProperties itself are project specific. For sinks, a possible
+         *  soundProperty could be for example settings.
+         */
+         am_SoundProperty_L listSoundProperties;
+        /**
+         * This list holds information about the formats that the Source is capable of
+         *  supporting when delivering audio.
+         */
+         am_ConnectionFormat_L listConnectionFormats;
+        /**
+         * This is the list of the available mainSoundProperties. The principle is the
+         *  same than with soundProperties, but they are only visible to the
+         *  CommandInterface.
+         */
+         am_MainSoundProperty_L listMainSoundProperties;
+        /**
+         * This is the list of the MainNotificationConfigurations. These notifications
+         *  work on the level of command interface.
+         */
+         am_NotificationConfiguration_L listMainNotificationConfigurations;
+        /**
+         * This is the list of the NotificationConfigurations. These notifications work on
+         *  the level of RoutingPlugins.
+         */
+         am_NotificationConfiguration_L listNotificationConfigurations;
+    
+        am_Sink_s() = default;
+        am_Sink_s(const am_sinkID_t& sinkID, const std::string& name, const am_domainID_t& domainID, const am_sinkClass_t& sinkClassID, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_MuteState_e& muteState, const am_mainVolume_t& mainVolume, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a source
+     */
+    /**
+     * This struct describes the attribiutes of a source
+     */
+    struct am_Source_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the source, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The domainID is the domain the source belongs to. A source can only be in one
+         *  domain.
+         */
+         am_domainID_t domainID;
+        /**
+         * The name of the source. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * the sourceClassID, indicates the class the source is in. This information can
+         *  be used by the Controller to implement different behaviour for different
+         *  classes.
+         */
+         am_sourceClass_t sourceClassID;
+        /**
+         * The source state is an indication towards the source if it is actively heard or
+         *  not. The source can use this information to implement features like automatic
+         *  spin down of CD's in case the CD is not the active source or AF following of a
+         *  tuner that is not actively heard. The source state is set by the
+         *  AudioManagerController.There are 3 possible states:
+        
+            SS_ON: the source is
+         *  active
+            SS_OFF: the source is off
+            SS_PAUSED: the source is paused and
+         *  not active.
+         */
+         am_SourceState_e sourceState;
+        /**
+         * This is the volume of the source. It is set by the AudioManagerController. It
+         *  is used to adopt different audiolevels in a system and mixing of sources (e.g.
+         *  navigation hints &amp; music).
+         */
+         am_volume_t volume;
+        /**
+         * This Boolean flag indicates whether a source is visible to the commandInterface
+         *  or not. If the User must have the possibility to choose the source in the HMI,
+         *  it must be visible. But there are also good reasons for invisible sources, for
+         *  example if the source is part of a crossfader or gateway. HMI relevant changes
+         *  in visible sources will be automatically reported by the daemon to the
+         *  commandInterface.
+         */
+         bool visible;
+        /**
+         * This attribute reflects the availability of the source. There are several
+         *  reasons why a source could be not available for the moment. For example a CD
+         *  player which has no CD entered in the slot can be unavailable, or a USB player
+         *  with no or unreadable stick attached. Other scenarios involve the shutdown of
+         *  a source because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two informations:
+        
+            Availablility: the status
+         *  itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s available;
+        /**
+         * Some special sources can have special behaviors, the are so called "Low Level
+         *  Interrupts". Here the current status is documented. The information can be
+         *  used by the AudioManagerController to react to the changes by for example
+         *  lowering the volume of the mainSources. The two states are
+        
+            IS_OFF: the
+         *  interrupt is not active at the moment
+            IS_INTERRUPTED: the interrupt is
+         *  playing at the moment.
+         */
+         am_InterruptState_e interruptState;
+        /**
+         * This is the list of soundProperties, that the source is capable of. The
+         *  soundProperties itself are project specific. For sources, a possible
+         *  soundProperty could be navigation volume offset, for example.
+         */
+         am_SoundProperty_L listSoundProperties;
+        /**
+         * This list holds information about the formats that the Source is capable of
+         *  supporting when delivering audio.
+         */
+         am_ConnectionFormat_L listConnectionFormats;
+        /**
+         * This is the list of the available mainSoundProperties. The principle is the
+         *  same than with soundProperties, but they are only visible to the
+         *  CommandInterface.
+         */
+         am_MainSoundProperty_L listMainSoundProperties;
+        /**
+         * The list of MainNotificationConfigurations. These notifications work on the
+         *  level of CommandInterface.
+         */
+         am_NotificationConfiguration_L listMainNotificationConfigurations;
+        /**
+         * The list of MainNotificationConfigurations. These notifications work on the
+         *  level of RoutingInterface.
+         */
+         am_NotificationConfiguration_L listNotificationConfigurations;
+    
+        am_Source_s() = default;
+        am_Source_s(const am_sourceID_t& sourceID, const am_domainID_t& domainID, const std::string& name, const am_sourceClass_t& sourceClassID, const am_SourceState_e& sourceState, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_InterruptState_e& interruptState, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a domain
+     */
+    /**
+     * This struct describes the attribiutes of a domain
+     */
+    struct am_Domain_s: CommonAPI::SerializableStruct {
+        /**
+         * the domain ID
+         */
+         am_domainID_t domainID;
+        /**
+         * the name of the domain
+         */
+         std::string name;
+        /**
+         * the busname. This is equal to a plugin name and is used to dispatch messages to
+         *  the elements of a plugin
+         */
+         std::string busname;
+        /**
+         * the name of the node
+         */
+         std::string nodename;
+        /**
+         * indicated if the domain is independent at startup or not
+         */
+         bool early;
+        /**
+         * indicates if the domain registration is complete or not
+         */
+         bool complete;
+        /**
+         * the current domain state
+         */
+         am_DomainState_e state;
+    
+        am_Domain_s() = default;
+        am_Domain_s(const am_domainID_t& domainID, const std::string& name, const std::string& busname, const std::string& nodename, const bool& early, const bool& complete, const am_DomainState_e& state);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    /**
+     * a connection
+     */
+    /**
+     * a connection
+     */
+    struct am_Connection_s: CommonAPI::SerializableStruct {
+        /**
+         * the assigned ID
+         */
+         am_connectionID_t connectionID;
+        /**
+         * the source the audio flows from
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sink the audio flows to
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the delay of the conneciton
+         */
+         am_timeSync_t delay;
+        /**
+         * the used connectionformat
+         */
+         am_CustomConnectionFormat_t connectionFormat;
+    
+        am_Connection_s() = default;
+        am_Connection_s(const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_CustomConnectionFormat_t& connectionFormat);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Availability_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Availability_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Availability_eComparator {
+    inline bool operator()(const am_Availability_e& lhs, const am_Availability_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_HotSink_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_HotSink_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_HotSink_eComparator {
+    inline bool operator()(const am_HotSink_e& lhs, const am_HotSink_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_ConnectionState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_ConnectionState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_ConnectionState_eComparator {
+    inline bool operator()(const am_ConnectionState_e& lhs, const am_ConnectionState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_DomainState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_DomainState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_DomainState_eComparator {
+    inline bool operator()(const am_DomainState_e& lhs, const am_DomainState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_EarlyDataType_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_EarlyDataType_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_EarlyDataType_eComparator {
+    inline bool operator()(const am_EarlyDataType_e& lhs, const am_EarlyDataType_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Error_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Error_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Error_eComparator {
+    inline bool operator()(const am_Error_e& lhs, const am_Error_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_MuteState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_MuteState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_MuteState_eComparator {
+    inline bool operator()(const am_MuteState_e& lhs, const am_MuteState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_InterruptState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_InterruptState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_InterruptState_eComparator {
+    inline bool operator()(const am_InterruptState_e& lhs, const am_InterruptState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_VolumeType_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_VolumeType_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_VolumeType_eComparator {
+    inline bool operator()(const am_VolumeType_e& lhs, const am_VolumeType_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_NotificationStatus_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_NotificationStatus_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_NotificationStatus_eComparator {
+    inline bool operator()(const am_NotificationStatus_e& lhs, const am_NotificationStatus_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Handle_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Handle_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Handle_eComparator {
+    inline bool operator()(const am_Handle_e& lhs, const am_Handle_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_SourceState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_SourceState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_SourceState_eComparator {
+    inline bool operator()(const am_SourceState_e& lhs, const am_SourceState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_RoutingReady_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_RoutingReady_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_RoutingReady_eComparator {
+    inline bool operator()(const am_RoutingReady_e& lhs, const am_RoutingReady_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+bool operator==(const am_Route_s& lhs, const am_Route_s& rhs);
+inline bool operator!=(const am_Route_s& lhs, const am_Route_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs);
+inline bool operator!=(const am_Availability_s& lhs, const am_Availability_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs);
+inline bool operator!=(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs);
+inline bool operator!=(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs);
+inline bool operator!=(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs);
+inline bool operator!=(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs);
+inline bool operator!=(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs);
+inline bool operator!=(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs);
+inline bool operator!=(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs);
+inline bool operator!=(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs);
+inline bool operator!=(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs);
+inline bool operator!=(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs);
+inline bool operator!=(const am_Handle_s& lhs, const am_Handle_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs);
+inline bool operator!=(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs);
+inline bool operator!=(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs);
+inline bool operator!=(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs);
+inline bool operator!=(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs);
+inline bool operator!=(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs);
+inline bool operator!=(const am_Sink_s& lhs, const am_Sink_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Source_s& lhs, const am_Source_s& rhs);
+inline bool operator!=(const am_Source_s& lhs, const am_Source_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs);
+inline bool operator!=(const am_Domain_s& lhs, const am_Domain_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs);
+inline bool operator!=(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs);
+inline bool operator!=(const am_Connection_s& lhs, const am_Connection_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs);
+inline bool operator!=(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
+    return !(lhs == rhs);
+}
+
+
+static inline const char* getTypeCollectionName() {
+    static const char* typeCollectionName = "org.genivi.am";
+    return typeCollectionName;
+}
+
+inline CommonAPI::Version getTypeCollectionVersion() {
+    return CommonAPI::Version(2, 0);
+}
+
+} // namespace am
+
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Availability_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Availability_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Availability_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_HotSink_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_ConnectionState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_DomainState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_EarlyDataType_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Error_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Error_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Error_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_MuteState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_InterruptState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_VolumeType_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_NotificationStatus_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Handle_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Handle_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Handle_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_SourceState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_RoutingReady_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+
+}
+
+
+namespace std {
+    //Hash for am_Availability_e
+    template<>
+    struct hash<org::genivi::am::am_Availability_e> {
+        inline size_t operator()(const org::genivi::am::am_Availability_e& am_Availability_e) const {
+            return static_cast<int32_t>(am_Availability_e);
+        }
+    };
+    //Hash for am_HotSink_e
+    template<>
+    struct hash<org::genivi::am::am_HotSink_e> {
+        inline size_t operator()(const org::genivi::am::am_HotSink_e& am_HotSink_e) const {
+            return static_cast<int32_t>(am_HotSink_e);
+        }
+    };
+    //Hash for am_ConnectionState_e
+    template<>
+    struct hash<org::genivi::am::am_ConnectionState_e> {
+        inline size_t operator()(const org::genivi::am::am_ConnectionState_e& am_ConnectionState_e) const {
+            return static_cast<int32_t>(am_ConnectionState_e);
+        }
+    };
+    //Hash for am_DomainState_e
+    template<>
+    struct hash<org::genivi::am::am_DomainState_e> {
+        inline size_t operator()(const org::genivi::am::am_DomainState_e& am_DomainState_e) const {
+            return static_cast<int32_t>(am_DomainState_e);
+        }
+    };
+    //Hash for am_EarlyDataType_e
+    template<>
+    struct hash<org::genivi::am::am_EarlyDataType_e> {
+        inline size_t operator()(const org::genivi::am::am_EarlyDataType_e& am_EarlyDataType_e) const {
+            return static_cast<int32_t>(am_EarlyDataType_e);
+        }
+    };
+    //Hash for am_Error_e
+    template<>
+    struct hash<org::genivi::am::am_Error_e> {
+        inline size_t operator()(const org::genivi::am::am_Error_e& am_Error_e) const {
+            return static_cast<int32_t>(am_Error_e);
+        }
+    };
+    //Hash for am_MuteState_e
+    template<>
+    struct hash<org::genivi::am::am_MuteState_e> {
+        inline size_t operator()(const org::genivi::am::am_MuteState_e& am_MuteState_e) const {
+            return static_cast<int32_t>(am_MuteState_e);
+        }
+    };
+    //Hash for am_InterruptState_e
+    template<>
+    struct hash<org::genivi::am::am_InterruptState_e> {
+        inline size_t operator()(const org::genivi::am::am_InterruptState_e& am_InterruptState_e) const {
+            return static_cast<int32_t>(am_InterruptState_e);
+        }
+    };
+    //Hash for am_VolumeType_e
+    template<>
+    struct hash<org::genivi::am::am_VolumeType_e> {
+        inline size_t operator()(const org::genivi::am::am_VolumeType_e& am_VolumeType_e) const {
+            return static_cast<int32_t>(am_VolumeType_e);
+        }
+    };
+    //Hash for am_NotificationStatus_e
+    template<>
+    struct hash<org::genivi::am::am_NotificationStatus_e> {
+        inline size_t operator()(const org::genivi::am::am_NotificationStatus_e& am_NotificationStatus_e) const {
+            return static_cast<int32_t>(am_NotificationStatus_e);
+        }
+    };
+    //Hash for am_Handle_e
+    template<>
+    struct hash<org::genivi::am::am_Handle_e> {
+        inline size_t operator()(const org::genivi::am::am_Handle_e& am_Handle_e) const {
+            return static_cast<int32_t>(am_Handle_e);
+        }
+    };
+    //Hash for am_SourceState_e
+    template<>
+    struct hash<org::genivi::am::am_SourceState_e> {
+        inline size_t operator()(const org::genivi::am::am_SourceState_e& am_SourceState_e) const {
+            return static_cast<int32_t>(am_SourceState_e);
+        }
+    };
+    //Hash for am_RoutingReady_e
+    template<>
+    struct hash<org::genivi::am::am_RoutingReady_e> {
+        inline size_t operator()(const org::genivi::am::am_RoutingReady_e& am_RoutingReady_e) const {
+            return static_cast<int32_t>(am_RoutingReady_e);
+        }
+    };
+}
+
+#endif // ORG_GENIVI_am_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.cpp b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.cpp
index 161a7b7..152c8b6 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.cpp
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h
index 17c0c51..dced63c 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -714,15 +712,15 @@ namespace am {
          am_NotificationStatus_e status;
         /**
          * This gives additional information to the notification status. 
-        Relation
-         *  between notification status and the value:
-        NS_PERIODIC - the period in
-         *  ms
-        NS_MINIMUM - the minimum value that triggers the notification
-        NS_MAXIMUM
-         *  - the maximum value that triggers the notifcation
-        NS_CHANGE - the resolution
-         *  of the change value
+        Relation between
+         *  notification status and the value:
+        NS_PERIODIC - the period in ms
+        NS_MINIMUM
+         *  - the minimum value that triggers the notification
+        NS_MAXIMUM - the maximum
+         *  value that triggers the notifcation
+        NS_CHANGE - the resolution of the change
+         *  value
          */
          int16_t parameter;
     
@@ -1155,8 +1153,8 @@ namespace am {
         /**
          * This enum can have 3 states:
         
-            HS_SINKA sinkA is the current hot one,
-         *  sinkB is not audible
+            HS_SINKA sinkA is the current hot one, sinkB
+         *  is not audible
             HS_SINKB sinkB is the current hot one, sinkB is not
          *  audible
             HS_INTERMEDIATE the fader is stuck in between a cross-fading
@@ -1571,11 +1569,11 @@ namespace am {
          *  tuner that is not actively heard. The source state is set by the
          *  AudioManagerController.There are 3 possible states:
         
-            SS_ON: the source
-         *  is active
+            SS_ON: the source is
+         *  active
             SS_OFF: the source is off
-            SS_PAUSED: the source is paused
-         *  and not active.
+            SS_PAUSED: the source is paused and
+         *  not active.
          */
          am_SourceState_e sourceState;
         /**
@@ -2076,7 +2074,7 @@ static inline const char* getTypeCollectionName() {
 }
 
 inline CommonAPI::Version getTypeCollectionVersion() {
-    return CommonAPI::Version(1, 0);
+    return CommonAPI::Version(2, 0);
 }
 
 } // namespace am
@@ -2096,7 +2094,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_Availability_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2117,7 +2114,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2138,7 +2134,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2159,7 +2154,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2180,7 +2174,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2201,7 +2194,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_Error_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2222,7 +2214,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2243,7 +2234,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2264,7 +2254,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2285,7 +2274,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2306,7 +2294,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_Handle_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2327,7 +2314,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
@@ -2348,7 +2334,6 @@ namespace CommonAPI {
     template<>
     struct InputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
         static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
-        	(void)vectorValue;
             inputStream.beginReadInt32EnumVector();
         }
     };
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControl.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControl.h
index eb103e5..922e4e0 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControl.h
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControl.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * The interface towards the Controlling Instance (e.g HMI). It handles the
@@ -47,7 +45,7 @@ const char* CommandControl::getInterfaceId() {
 }
 
 CommonAPI::Version CommandControl::getInterfaceVersion() {
-    return CommonAPI::Version(1, 0);
+    return CommonAPI::Version(2, 0);
 }
 
 
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.cpp b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.cpp
index e147744..f6b6af9 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.cpp
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * The interface towards the Controlling Instance (e.g HMI). It handles the
@@ -31,11 +29,11 @@ std::shared_ptr<CommonAPI::DBus::DBusProxy> createCommandControlDBusProxy(
     return std::make_shared<CommandControlDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
 }
 
-__attribute__((constructor)) void registerCommandControlDBusProxy(void) {
+INITIALIZER(registerCommandControlDBusProxy) {
     CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(CommandControl::getInterfaceId(),
        &createCommandControlDBusProxy);
 }
- 
+
 CommandControlDBusProxy::CommandControlDBusProxy(
                     const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                     const std::string& commonApiAddress,
@@ -216,26 +214,26 @@ std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setVolumeAsync(const
 /**
  * This function is used to increment or decrement the current volume for a
  *  sink.
-(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
- *  the value is not in the given volume range.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
  */
-void CommandControlDBusProxy::volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep_, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+void CommandControlDBusProxy::volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
     CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, int16_t>,
                                      CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
         *this,
         "volumeStep",
         "qn",
-        sinkID, volumeStep_,
+        sinkID, volStep,
         callStatus
         , error);
 }
-std::future<CommonAPI::CallStatus> CommandControlDBusProxy::volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep_, VolumeStepAsyncCallback callback) {
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback) {
     return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, int16_t>,
                                      CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
         *this,
         "volumeStep",
         "qn",
-        sinkID, volumeStep_, 
+        sinkID, volStep, 
         std::move(callback));
 }
 /**
@@ -384,8 +382,8 @@ std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSinksAsyn
 }
 /**
  * returns the actual list of Sources
-(at)return E_OK on success,
- *  E_DATABASE_ERROR on error
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
  */
 void CommandControlDBusProxy::getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error) {
     CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
@@ -407,8 +405,8 @@ std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSourcesAs
 /**
  * This is used to retrieve all source sound properties related to a source.
  *  Returns a vector of the sound properties and values as pair
-(at)return E_OK
- *  on success, E_DATABASE_ERROR on error
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
  */
 void CommandControlDBusProxy::getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
     CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
@@ -644,7 +642,7 @@ std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSourceNotific
 
 
 void CommandControlDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
-    ownVersionMajor = 1;
+    ownVersionMajor = 2;
     ownVersionMinor = 0;
 }
 
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.h
index 64091a7..4d72e39 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.h
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * The interface towards the Controlling Instance (e.g HMI). It handles the
@@ -97,11 +95,11 @@ class CommandControlDBusProxy: virtual public CommandControlProxyBase, virtual p
     /**
      * This function is used to increment or decrement the current volume for a
      *  sink.
-    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
-     *  the value is not in the given volume range.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
      */
-    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep_, CommonAPI::CallStatus& callStatus, am_Error_e& error);
-    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep_, VolumeStepAsyncCallback callback);
+    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback);
     /**
      * sets the mute state of a sink
     (at)return E_OK on success, E_UNKNOWN on error.
@@ -150,16 +148,16 @@ class CommandControlDBusProxy: virtual public CommandControlProxyBase, virtual p
     virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback callback);
     /**
      * returns the actual list of Sources
-    (at)return E_OK on success,
-     *  E_DATABASE_ERROR on error
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
      */
     virtual void getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error);
     virtual std::future<CommonAPI::CallStatus> getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback);
     /**
      * This is used to retrieve all source sound properties related to a source.
      *  Returns a vector of the sound properties and values as pair
-    (at)return E_OK
-     *  on success, E_DATABASE_ERROR on error
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
      */
     virtual void getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
     virtual std::future<CommonAPI::CallStatus> getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback);
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.cpp b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.cpp
index db01c28..60d8871 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.cpp
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include "CommandControlDBusStubAdapter.h"
 #include <org/genivi/am/CommandControl.h>
@@ -25,7 +23,7 @@ std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createCommandControlDBusStubAd
     return std::make_shared<CommandControlDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
 }
 
-__attribute__((constructor)) void registerCommandControlDBusStubAdapter(void) {
+INITIALIZER(registerCommandControlDBusStubAdapter) {
     CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(CommandControl::getInterfaceId(),
                                                                &createCommandControlDBusStubAdapter);
 }
@@ -38,6 +36,7 @@ CommandControlDBusStubAdapterInternal::~CommandControlDBusStubAdapterInternal()
 }
 
 void CommandControlDBusStubAdapterInternal::deactivateManagedInstances() {
+
 }
 
 const char* CommandControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
@@ -230,12 +229,12 @@ const char* CommandControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXm
         /**
          * This function is used to increment or decrement the current volume for a
          *  sink.
-        (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
-         *  the value is not in the given volume range.
+        (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+         *  value is not in the given volume range.
          */
         "<method name=\"volumeStep\">\n"
             "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
-            "<arg name=\"volumeStep_\" type=\"n\" direction=\"in\" />\n"
+            "<arg name=\"volStep\" type=\"n\" direction=\"in\" />\n"
             "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
         "</method>\n"
         /**
@@ -301,8 +300,8 @@ const char* CommandControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXm
         "</method>\n"
         /**
          * returns the actual list of Sources
-        (at)return E_OK on success,
-         *  E_DATABASE_ERROR on error
+        (at)return E_OK on success, E_DATABASE_ERROR
+         *  on error
          */
         "<method name=\"getListMainSources\">\n"
             "<arg name=\"listMainSources\" type=\"a(qs(iq)q)\" direction=\"out\" />\n"
@@ -311,8 +310,8 @@ const char* CommandControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXm
         /**
          * This is used to retrieve all source sound properties related to a source.
          *  Returns a vector of the sound properties and values as pair
-        (at)return E_OK
-         *  on success, E_DATABASE_ERROR on error
+        (at)return E_OK on
+         *  success, E_DATABASE_ERROR on error
          */
         "<method name=\"getListMainSinkSoundProperties\">\n"
             "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
@@ -412,10 +411,11 @@ const char* CommandControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXm
     return introspectionData.c_str();
 }
 
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         CommandControlStub,
         CommonAPI::Version
-        > getCommandControlInterfaceVersionStubDispatcher(&CommandControlStub::getInterfaceVersion, "uu");
+        > CommandControlDBusStubAdapterInternal::getCommandControlInterfaceVersionStubDispatcher(&CommandControlStub::getInterfaceVersion, "uu");
+
 
 
 /**
@@ -423,52 +423,52 @@ static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
 (at)return E_OK on success, E_NOT_POSSIBLE on
  *  failure, E_ALREADY_EXISTS if the connection does already exists
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sourceID_t, am_sinkID_t>,
     std::tuple<am_mainConnectionID_t, am_Error_e>
-    > connectStubDispatcher(&CommandControlStub::connect, "qi");
+    > CommandControlDBusStubAdapterInternal::connectStubDispatcher(&CommandControlStub::connect, "qi");
 /**
  * disconnects a mainConnection
 (at)return E_OK on successes, E_NON_EXISTENT if
  *  the connection does not exist, E_NOT_POSSIBLE on error.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_mainConnectionID_t>,
     std::tuple<am_Error_e>
-    > disconnectStubDispatcher(&CommandControlStub::disconnect, "i");
+    > CommandControlDBusStubAdapterInternal::disconnectStubDispatcher(&CommandControlStub::disconnect, "i");
 /**
  * sets the volume for a sink
 (at)return E_OK on success, E_UNKOWN on error,
  *  E_OUT_OF_RANGE in case the value is out of range
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sinkID_t, am_mainVolume_t>,
     std::tuple<am_Error_e>
-    > setVolumeStubDispatcher(&CommandControlStub::setVolume, "i");
+    > CommandControlDBusStubAdapterInternal::setVolumeStubDispatcher(&CommandControlStub::setVolume, "i");
 /**
  * This function is used to increment or decrement the current volume for a
  *  sink.
-(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
- *  the value is not in the given volume range.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sinkID_t, int16_t>,
     std::tuple<am_Error_e>
-    > volumeStepStubDispatcher(&CommandControlStub::volumeStep, "i");
+    > CommandControlDBusStubAdapterInternal::volumeStepStubDispatcher(&CommandControlStub::volumeStep, "i");
 /**
  * sets the mute state of a sink
 (at)return E_OK on success, E_UNKNOWN on error.
  *  If the mute state is already the desired one, the Daemon will return E_OK.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sinkID_t, am_MuteState_e>,
     std::tuple<am_Error_e>
-    > setSinkMuteStateStubDispatcher(&CommandControlStub::setSinkMuteState, "i");
+    > CommandControlDBusStubAdapterInternal::setSinkMuteStateStubDispatcher(&CommandControlStub::setSinkMuteState, "i");
 /**
  * This method is used to set sound properties, e.g. Equalizer Values. Since the
  *  capabilities of the system can differ, the exact key value pairs can be
@@ -476,11 +476,11 @@ static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
 (at)return E_OK on success, E_OUT_OF_RANGE if value
  *  exceeds range, E_UNKNOWN in case of an error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sinkID_t, am_MainSoundProperty_s>,
     std::tuple<am_Error_e>
-    > setMainSinkSoundPropertyStubDispatcher(&CommandControlStub::setMainSinkSoundProperty, "i");
+    > CommandControlDBusStubAdapterInternal::setMainSinkSoundPropertyStubDispatcher(&CommandControlStub::setMainSinkSoundProperty, "i");
 /**
  * This method is used to set sound properties, e.g. Equalizer Values. Since the
  *  capabilities of the system can differ, the exact key value pairs can be
@@ -488,153 +488,154 @@ static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
 (at)return E_OK on success, E_OUT_OF_RANGE if value
  *  exceeds range, E_UNKNOWN in case of an error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sourceID_t, am_MainSoundProperty_s>,
     std::tuple<am_Error_e>
-    > setMainSourceSoundPropertyStubDispatcher(&CommandControlStub::setMainSourceSoundProperty, "i");
+    > CommandControlDBusStubAdapterInternal::setMainSourceSoundPropertyStubDispatcher(&CommandControlStub::setMainSourceSoundProperty, "i");
 /**
  * is used to set a specific system property.
 (at)return E_OK on success,
  *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_SystemProperty_s>,
     std::tuple<am_Error_e>
-    > setSystemPropertyStubDispatcher(&CommandControlStub::setSystemProperty, "i");
+    > CommandControlDBusStubAdapterInternal::setSystemPropertyStubDispatcher(&CommandControlStub::setSystemProperty, "i");
 /**
  * returns the actual list of MainConnections
 (at)return E_OK on success,
  *  E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<>,
     std::tuple<am_MainConnection_L, am_Error_e>
-    > getListMainConnectionsStubDispatcher(&CommandControlStub::getListMainConnections, "a(qqqni)i");
+    > CommandControlDBusStubAdapterInternal::getListMainConnectionsStubDispatcher(&CommandControlStub::getListMainConnections, "a(qqqni)i");
 /**
  * returns the actual list of Sinks
 (at)return E_OK on success, E_DATABASE_ERROR
  *  on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<>,
     std::tuple<am_SinkType_L, am_Error_e>
-    > getListMainSinksStubDispatcher(&CommandControlStub::getListMainSinks, "a(qs(iq)niq)i");
+    > CommandControlDBusStubAdapterInternal::getListMainSinksStubDispatcher(&CommandControlStub::getListMainSinks, "a(qs(iq)niq)i");
 /**
  * returns the actual list of Sources
-(at)return E_OK on success,
- *  E_DATABASE_ERROR on error
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<>,
     std::tuple<am_SourceType_L, am_Error_e>
-    > getListMainSourcesStubDispatcher(&CommandControlStub::getListMainSources, "a(qs(iq)q)i");
+    > CommandControlDBusStubAdapterInternal::getListMainSourcesStubDispatcher(&CommandControlStub::getListMainSources, "a(qs(iq)q)i");
 /**
  * This is used to retrieve all source sound properties related to a source.
  *  Returns a vector of the sound properties and values as pair
-(at)return E_OK
- *  on success, E_DATABASE_ERROR on error
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sinkID_t>,
     std::tuple<am_MainSoundProperty_L, am_Error_e>
-    > getListMainSinkSoundPropertiesStubDispatcher(&CommandControlStub::getListMainSinkSoundProperties, "a(qn)i");
+    > CommandControlDBusStubAdapterInternal::getListMainSinkSoundPropertiesStubDispatcher(&CommandControlStub::getListMainSinkSoundProperties, "a(qn)i");
 /**
  * This is used to retrieve all source sound properties related to a
  *  source.
 (at)return E_OK on success, E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sourceID_t>,
     std::tuple<am_MainSoundProperty_L, am_Error_e>
-    > getListMainSourceSoundPropertiesStubDispatcher(&CommandControlStub::getListMainSourceSoundProperties, "a(qn)i");
+    > CommandControlDBusStubAdapterInternal::getListMainSourceSoundPropertiesStubDispatcher(&CommandControlStub::getListMainSourceSoundProperties, "a(qn)i");
 /**
  * This is used to retrieve SourceClass Information of all source classes
  *  
 (at)return E_OK on success, E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<>,
     std::tuple<am_SourceClass_L, am_Error_e>
-    > getListSourceClassesStubDispatcher(&CommandControlStub::getListSourceClasses, "a(qsa(qn))i");
+    > CommandControlDBusStubAdapterInternal::getListSourceClassesStubDispatcher(&CommandControlStub::getListSourceClasses, "a(qsa(qn))i");
 /**
  * This is used to retrieve SinkClass Information of all sink classes 
 (at)return
  *  E_OK on success, E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<>,
     std::tuple<am_SinkClass_L, am_Error_e>
-    > getListSinkClassesStubDispatcher(&CommandControlStub::getListSinkClasses, "a(qsa(qn))i");
+    > CommandControlDBusStubAdapterInternal::getListSinkClassesStubDispatcher(&CommandControlStub::getListSinkClasses, "a(qsa(qn))i");
 /**
  * Retrieves a complete list of all systemProperties.
 (at)return E_OK on success,
  *  E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<>,
     std::tuple<am_SystemProperty_L, am_Error_e>
-    > getListSystemPropertiesStubDispatcher(&CommandControlStub::getListSystemProperties, "a(qn)i");
+    > CommandControlDBusStubAdapterInternal::getListSystemPropertiesStubDispatcher(&CommandControlStub::getListSystemProperties, "a(qn)i");
 /**
  * returns the delay in ms that the audiopath for the given mainConnection
  *  has
 (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
  *  yet retrieved, E_DATABASE_ERROR on read error on the database
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_mainConnectionID_t>,
     std::tuple<am_timeSync_t, am_Error_e>
-    > getTimingInformationStubDispatcher(&CommandControlStub::getTimingInformation, "ni");
+    > CommandControlDBusStubAdapterInternal::getTimingInformationStubDispatcher(&CommandControlStub::getTimingInformation, "ni");
 /**
  * Retrieves the list of MainNotifications for a sink. Does not return the
  *  possible ones.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sinkID_t>,
     std::tuple<am_NotificationConfiguration_L, am_Error_e>
-    > getListMainSinkNotificationConfigurationsStubDispatcher(&CommandControlStub::getListMainSinkNotificationConfigurations, "a(qin)i");
+    > CommandControlDBusStubAdapterInternal::getListMainSinkNotificationConfigurationsStubDispatcher(&CommandControlStub::getListMainSinkNotificationConfigurations, "a(qin)i");
 /**
  * Retrieves the list of MainNotifications for a source. Does not return the
  *  possible ones.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sourceID_t>,
     std::tuple<am_NotificationConfiguration_L, am_Error_e>
-    > getListMainSourceNotificationConfigurationsStubDispatcher(&CommandControlStub::getListMainSourceNotificationConfigurations, "a(qin)i");
+    > CommandControlDBusStubAdapterInternal::getListMainSourceNotificationConfigurationsStubDispatcher(&CommandControlStub::getListMainSourceNotificationConfigurations, "a(qin)i");
 /**
  * sets a MainNotificationConfiuration. This can be used to turn on an off
  *  notifications an to change the mode of the configuration.
 (at)return E_OK on
  *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sinkID_t, am_NotificationConfiguration_s>,
     std::tuple<am_Error_e>
-    > setMainSinkNotificationConfigurationStubDispatcher(&CommandControlStub::setMainSinkNotificationConfiguration, "i");
+    > CommandControlDBusStubAdapterInternal::setMainSinkNotificationConfigurationStubDispatcher(&CommandControlStub::setMainSinkNotificationConfiguration, "i");
 /**
  * sets a MainNotificationConfiuration. This can be used to turn on an off
  *  notifications an to change the mode of the configuration.
 (at)return E_OK on
  *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     CommandControlStub,
     std::tuple<am_sourceID_t, am_NotificationConfiguration_s>,
     std::tuple<am_Error_e>
-    > setMainSourceNotificationConfigurationStubDispatcher(&CommandControlStub::setMainSourceNotificationConfiguration, "i");
+    > CommandControlDBusStubAdapterInternal::setMainSourceNotificationConfigurationStubDispatcher(&CommandControlStub::setMainSourceNotificationConfiguration, "i");
+
 
 
 /**
@@ -912,10 +913,14 @@ void CommandControlDBusStubAdapterInternal::fireMainSourceNotificationConfigurat
         );
 }
 
+
 const CommandControlDBusStubAdapterHelper::StubDispatcherTable& CommandControlDBusStubAdapterInternal::getStubDispatcherTable() {
     return stubDispatcherTable_;
 }
 
+const CommonAPI::DBus::StubAttributeTable& CommandControlDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
 
 CommandControlDBusStubAdapterInternal::CommandControlDBusStubAdapterInternal(
         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -948,32 +953,32 @@ CommandControlDBusStubAdapterInternal::CommandControlDBusStubAdapterInternal(
             (at)return E_OK on success, E_NOT_POSSIBLE on
              *  failure, E_ALREADY_EXISTS if the connection does already exists
              */
-            { { "connect", "qq" }, &org::genivi::am::connectStubDispatcher },
+            { { "connect", "qq" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::connectStubDispatcher },
             /**
              * disconnects a mainConnection
             (at)return E_OK on successes, E_NON_EXISTENT if
              *  the connection does not exist, E_NOT_POSSIBLE on error.
              */
-            { { "disconnect", "q" }, &org::genivi::am::disconnectStubDispatcher },
+            { { "disconnect", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::disconnectStubDispatcher },
             /**
              * sets the volume for a sink
             (at)return E_OK on success, E_UNKOWN on error,
              *  E_OUT_OF_RANGE in case the value is out of range
              */
-            { { "setVolume", "qn" }, &org::genivi::am::setVolumeStubDispatcher },
+            { { "setVolume", "qn" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setVolumeStubDispatcher },
             /**
              * This function is used to increment or decrement the current volume for a
              *  sink.
-            (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
-             *  the value is not in the given volume range.
+            (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+             *  value is not in the given volume range.
              */
-            { { "volumeStep", "qn" }, &org::genivi::am::volumeStepStubDispatcher },
+            { { "volumeStep", "qn" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::volumeStepStubDispatcher },
             /**
              * sets the mute state of a sink
             (at)return E_OK on success, E_UNKNOWN on error.
              *  If the mute state is already the desired one, the Daemon will return E_OK.
              */
-            { { "setSinkMuteState", "qi" }, &org::genivi::am::setSinkMuteStateStubDispatcher },
+            { { "setSinkMuteState", "qi" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setSinkMuteStateStubDispatcher },
             /**
              * This method is used to set sound properties, e.g. Equalizer Values. Since the
              *  capabilities of the system can differ, the exact key value pairs can be
@@ -981,7 +986,7 @@ CommandControlDBusStubAdapterInternal::CommandControlDBusStubAdapterInternal(
             (at)return E_OK on success, E_OUT_OF_RANGE if value
              *  exceeds range, E_UNKNOWN in case of an error
              */
-            { { "setMainSinkSoundProperty", "q(qn)" }, &org::genivi::am::setMainSinkSoundPropertyStubDispatcher },
+            { { "setMainSinkSoundProperty", "q(qn)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setMainSinkSoundPropertyStubDispatcher },
             /**
              * This method is used to set sound properties, e.g. Equalizer Values. Since the
              *  capabilities of the system can differ, the exact key value pairs can be
@@ -989,96 +994,101 @@ CommandControlDBusStubAdapterInternal::CommandControlDBusStubAdapterInternal(
             (at)return E_OK on success, E_OUT_OF_RANGE if value
              *  exceeds range, E_UNKNOWN in case of an error
              */
-            { { "setMainSourceSoundProperty", "q(qn)" }, &org::genivi::am::setMainSourceSoundPropertyStubDispatcher },
+            { { "setMainSourceSoundProperty", "q(qn)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setMainSourceSoundPropertyStubDispatcher },
             /**
              * is used to set a specific system property.
             (at)return E_OK on success,
              *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
              */
-            { { "setSystemProperty", "(qn)" }, &org::genivi::am::setSystemPropertyStubDispatcher },
+            { { "setSystemProperty", "(qn)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setSystemPropertyStubDispatcher },
             /**
              * returns the actual list of MainConnections
             (at)return E_OK on success,
              *  E_DATABASE_ERROR on error
              */
-            { { "getListMainConnections", "" }, &org::genivi::am::getListMainConnectionsStubDispatcher },
+            { { "getListMainConnections", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainConnectionsStubDispatcher },
             /**
              * returns the actual list of Sinks
             (at)return E_OK on success, E_DATABASE_ERROR
              *  on error
              */
-            { { "getListMainSinks", "" }, &org::genivi::am::getListMainSinksStubDispatcher },
+            { { "getListMainSinks", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSinksStubDispatcher },
             /**
              * returns the actual list of Sources
-            (at)return E_OK on success,
-             *  E_DATABASE_ERROR on error
+            (at)return E_OK on success, E_DATABASE_ERROR
+             *  on error
              */
-            { { "getListMainSources", "" }, &org::genivi::am::getListMainSourcesStubDispatcher },
+            { { "getListMainSources", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSourcesStubDispatcher },
             /**
              * This is used to retrieve all source sound properties related to a source.
              *  Returns a vector of the sound properties and values as pair
-            (at)return E_OK
-             *  on success, E_DATABASE_ERROR on error
+            (at)return E_OK on
+             *  success, E_DATABASE_ERROR on error
              */
-            { { "getListMainSinkSoundProperties", "q" }, &org::genivi::am::getListMainSinkSoundPropertiesStubDispatcher },
+            { { "getListMainSinkSoundProperties", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSinkSoundPropertiesStubDispatcher },
             /**
              * This is used to retrieve all source sound properties related to a
              *  source.
             (at)return E_OK on success, E_DATABASE_ERROR on error
              */
-            { { "getListMainSourceSoundProperties", "q" }, &org::genivi::am::getListMainSourceSoundPropertiesStubDispatcher },
+            { { "getListMainSourceSoundProperties", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSourceSoundPropertiesStubDispatcher },
             /**
              * This is used to retrieve SourceClass Information of all source classes
              *  
             (at)return E_OK on success, E_DATABASE_ERROR on error
              */
-            { { "getListSourceClasses", "" }, &org::genivi::am::getListSourceClassesStubDispatcher },
+            { { "getListSourceClasses", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListSourceClassesStubDispatcher },
             /**
              * This is used to retrieve SinkClass Information of all sink classes 
             (at)return
              *  E_OK on success, E_DATABASE_ERROR on error
              */
-            { { "getListSinkClasses", "" }, &org::genivi::am::getListSinkClassesStubDispatcher },
+            { { "getListSinkClasses", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListSinkClassesStubDispatcher },
             /**
              * Retrieves a complete list of all systemProperties.
             (at)return E_OK on success,
              *  E_DATABASE_ERROR on error
              */
-            { { "getListSystemProperties", "" }, &org::genivi::am::getListSystemPropertiesStubDispatcher },
+            { { "getListSystemProperties", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListSystemPropertiesStubDispatcher },
             /**
              * returns the delay in ms that the audiopath for the given mainConnection
              *  has
             (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
              *  yet retrieved, E_DATABASE_ERROR on read error on the database
              */
-            { { "getTimingInformation", "q" }, &org::genivi::am::getTimingInformationStubDispatcher },
+            { { "getTimingInformation", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getTimingInformationStubDispatcher },
             /**
              * Retrieves the list of MainNotifications for a sink. Does not return the
              *  possible ones.
              */
-            { { "getListMainSinkNotificationConfigurations", "q" }, &org::genivi::am::getListMainSinkNotificationConfigurationsStubDispatcher },
+            { { "getListMainSinkNotificationConfigurations", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSinkNotificationConfigurationsStubDispatcher },
             /**
              * Retrieves the list of MainNotifications for a source. Does not return the
              *  possible ones.
              */
-            { { "getListMainSourceNotificationConfigurations", "q" }, &org::genivi::am::getListMainSourceNotificationConfigurationsStubDispatcher },
+            { { "getListMainSourceNotificationConfigurations", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSourceNotificationConfigurationsStubDispatcher },
             /**
              * sets a MainNotificationConfiuration. This can be used to turn on an off
              *  notifications an to change the mode of the configuration.
             (at)return E_OK on
              *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
              */
-            { { "setMainSinkNotificationConfiguration", "q(qin)" }, &org::genivi::am::setMainSinkNotificationConfigurationStubDispatcher },
+            { { "setMainSinkNotificationConfiguration", "q(qin)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setMainSinkNotificationConfigurationStubDispatcher },
             /**
              * sets a MainNotificationConfiuration. This can be used to turn on an off
              *  notifications an to change the mode of the configuration.
             (at)return E_OK on
              *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
              */
-            { { "setMainSourceNotificationConfiguration", "q(qin)" }, &org::genivi::am::setMainSourceNotificationConfigurationStubDispatcher }
-            }) {
+            { { "setMainSourceNotificationConfiguration", "q(qin)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setMainSourceNotificationConfigurationStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getCommandControlInterfaceVersionStubDispatcher });
+}
 
-    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::getCommandControlInterfaceVersionStubDispatcher });
+const bool CommandControlDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
 }
 
 } // namespace am
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.h
index 8ef3355..1c5ba0d 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.h
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * The interface towards the Controlling Instance (e.g HMI). It handles the
@@ -37,7 +35,7 @@ namespace am {
 
 typedef CommonAPI::DBus::DBusStubAdapterHelper<CommandControlStub> CommandControlDBusStubAdapterHelper;
 
-class CommandControlDBusStubAdapterInternal: public CommandControlStubAdapter, public CommandControlDBusStubAdapterHelper {
+class CommandControlDBusStubAdapterInternal: public virtual CommandControlStubAdapter, public CommandControlDBusStubAdapterHelper {
  public:
     CommandControlDBusStubAdapterInternal(
             const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -50,6 +48,8 @@ class CommandControlDBusStubAdapterInternal: public CommandControlStubAdapter, p
 
     ~CommandControlDBusStubAdapterInternal();
 
+    virtual const bool hasFreedesktopProperties();
+
 
     /**
      * Callback that is called when the number of connections change
@@ -146,15 +146,245 @@ class CommandControlDBusStubAdapterInternal: public CommandControlStubAdapter, p
 
 
     const CommandControlDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
 
     void deactivateManagedInstances();
 
 
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        CommandControlStub,
+        CommonAPI::Version
+        > getCommandControlInterfaceVersionStubDispatcher;
+
+
+
+/**
+ * connects a source to sink
+(at)return E_OK on success, E_NOT_POSSIBLE on
+ *  failure, E_ALREADY_EXISTS if the connection does already exists
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_sinkID_t>,
+    std::tuple<am_mainConnectionID_t, am_Error_e>
+    > connectStubDispatcher;
+/**
+ * disconnects a mainConnection
+(at)return E_OK on successes, E_NON_EXISTENT if
+ *  the connection does not exist, E_NOT_POSSIBLE on error.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_mainConnectionID_t>,
+    std::tuple<am_Error_e>
+    > disconnectStubDispatcher;
+/**
+ * sets the volume for a sink
+(at)return E_OK on success, E_UNKOWN on error,
+ *  E_OUT_OF_RANGE in case the value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_mainVolume_t>,
+    std::tuple<am_Error_e>
+    > setVolumeStubDispatcher;
+/**
+ * This function is used to increment or decrement the current volume for a
+ *  sink.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, int16_t>,
+    std::tuple<am_Error_e>
+    > volumeStepStubDispatcher;
+/**
+ * sets the mute state of a sink
+(at)return E_OK on success, E_UNKNOWN on error.
+ *  If the mute state is already the desired one, the Daemon will return E_OK.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_MuteState_e>,
+    std::tuple<am_Error_e>
+    > setSinkMuteStateStubDispatcher;
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_MainSoundProperty_s>,
+    std::tuple<am_Error_e>
+    > setMainSinkSoundPropertyStubDispatcher;
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_MainSoundProperty_s>,
+    std::tuple<am_Error_e>
+    > setMainSourceSoundPropertyStubDispatcher;
+/**
+ * is used to set a specific system property.
+(at)return E_OK on success,
+ *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_SystemProperty_s>,
+    std::tuple<am_Error_e>
+    > setSystemPropertyStubDispatcher;
+/**
+ * returns the actual list of MainConnections
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_MainConnection_L, am_Error_e>
+    > getListMainConnectionsStubDispatcher;
+/**
+ * returns the actual list of Sinks
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SinkType_L, am_Error_e>
+    > getListMainSinksStubDispatcher;
+/**
+ * returns the actual list of Sources
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SourceType_L, am_Error_e>
+    > getListMainSourcesStubDispatcher;
+/**
+ * This is used to retrieve all source sound properties related to a source.
+ *  Returns a vector of the sound properties and values as pair
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_MainSoundProperty_L, am_Error_e>
+    > getListMainSinkSoundPropertiesStubDispatcher;
+/**
+ * This is used to retrieve all source sound properties related to a
+ *  source.
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_MainSoundProperty_L, am_Error_e>
+    > getListMainSourceSoundPropertiesStubDispatcher;
+/**
+ * This is used to retrieve SourceClass Information of all source classes
+ *  
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SourceClass_L, am_Error_e>
+    > getListSourceClassesStubDispatcher;
+/**
+ * This is used to retrieve SinkClass Information of all sink classes 
+(at)return
+ *  E_OK on success, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SinkClass_L, am_Error_e>
+    > getListSinkClassesStubDispatcher;
+/**
+ * Retrieves a complete list of all systemProperties.
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SystemProperty_L, am_Error_e>
+    > getListSystemPropertiesStubDispatcher;
+/**
+ * returns the delay in ms that the audiopath for the given mainConnection
+ *  has
+(at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+ *  yet retrieved, E_DATABASE_ERROR on read error on the database
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_mainConnectionID_t>,
+    std::tuple<am_timeSync_t, am_Error_e>
+    > getTimingInformationStubDispatcher;
+/**
+ * Retrieves the list of MainNotifications for a sink. Does not return the
+ *  possible ones.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_NotificationConfiguration_L, am_Error_e>
+    > getListMainSinkNotificationConfigurationsStubDispatcher;
+/**
+ * Retrieves the list of MainNotifications for a source. Does not return the
+ *  possible ones.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_NotificationConfiguration_L, am_Error_e>
+    > getListMainSourceNotificationConfigurationsStubDispatcher;
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_NotificationConfiguration_s>,
+    std::tuple<am_Error_e>
+    > setMainSinkNotificationConfigurationStubDispatcher;
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_NotificationConfiguration_s>,
+    std::tuple<am_Error_e>
+    > setMainSourceNotificationConfigurationStubDispatcher;
+
+
+
+
  protected:
     virtual const char* getMethodsDBusIntrospectionXmlData() const;
-    
-  private:
+
+ private:
     CommandControlDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
 };
 
 class CommandControlDBusStubAdapter: public CommandControlDBusStubAdapterInternal, public std::enable_shared_from_this<CommandControlDBusStubAdapter> {
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxy.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxy.h
index 656d3f7..c628cd6 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxy.h
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * The interface towards the Controlling Instance (e.g HMI). It handles the
@@ -329,8 +327,8 @@ public:
     /**
      * This function is used to increment or decrement the current volume for a
      *  sink.
-    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
-     *  the value is not in the given volume range.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
      * 
      * Calls volumeStep with synchronous semantics.
      * 
@@ -340,7 +338,7 @@ public:
      * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
      * will be set.
      */
-    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep_, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error);
     /**
      * Calls volumeStep with asynchronous semantics.
      * 
@@ -351,7 +349,7 @@ public:
      * The std::future returned by this method will be fulfilled at arrival of the reply.
      * It will provide the same value for CallStatus as will be handed to the callback.
      */
-    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep_, VolumeStepAsyncCallback callback);
+    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback);
     /**
      * sets the mute state of a sink
     (at)return E_OK on success, E_UNKNOWN on error.
@@ -506,8 +504,8 @@ public:
     virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback callback);
     /**
      * returns the actual list of Sources
-    (at)return E_OK on success,
-     *  E_DATABASE_ERROR on error
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
      * 
      * Calls getListMainSources with synchronous semantics.
      * 
@@ -531,8 +529,8 @@ public:
     /**
      * This is used to retrieve all source sound properties related to a source.
      *  Returns a vector of the sound properties and values as pair
-    (at)return E_OK
-     *  on success, E_DATABASE_ERROR on error
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
      * 
      * Calls getListMainSinkSoundProperties with synchronous semantics.
      * 
@@ -825,14 +823,20 @@ public:
     std::shared_ptr<CommandControlProxyBase> delegate_;
 };
 
+#ifdef WIN32
+    typedef CommandControlProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> CommandControlProxyDefault;
+#else
+    typedef CommandControlProxy<> CommandControlProxyDefault;
+#endif
+
 
 //
 // CommandControlProxy Implementation
 //
 template <typename ... _AttributeExtensions>
 CommandControlProxy<_AttributeExtensions...>::CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
-        delegate_(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)),
-        _AttributeExtensions(*(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)))... {
+        _AttributeExtensions(*(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)) {
 }
 
 template <typename ... _AttributeExtensions>
@@ -884,17 +888,17 @@ std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>:
 /**
  * This function is used to increment or decrement the current volume for a
  *  sink.
-(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
- *  the value is not in the given volume range.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
  */
 template <typename ... _AttributeExtensions>
-void CommandControlProxy<_AttributeExtensions...>::volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep_, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
-    delegate_->volumeStep(sinkID, volumeStep_, callStatus, error);
+void CommandControlProxy<_AttributeExtensions...>::volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->volumeStep(sinkID, volStep, callStatus, error);
 }
 
 template <typename ... _AttributeExtensions>
-std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep_, VolumeStepAsyncCallback callback) {
-    return delegate_->volumeStepAsync(sinkID, volumeStep_, callback);
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback) {
+    return delegate_->volumeStepAsync(sinkID, volStep, callback);
 }
 /**
  * sets the mute state of a sink
@@ -986,8 +990,8 @@ std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>:
 }
 /**
  * returns the actual list of Sources
-(at)return E_OK on success,
- *  E_DATABASE_ERROR on error
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
  */
 template <typename ... _AttributeExtensions>
 void CommandControlProxy<_AttributeExtensions...>::getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error) {
@@ -1001,8 +1005,8 @@ std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>:
 /**
  * This is used to retrieve all source sound properties related to a source.
  *  Returns a vector of the sound properties and values as pair
-(at)return E_OK
- *  on success, E_DATABASE_ERROR on error
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
  */
 template <typename ... _AttributeExtensions>
 void CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxyBase.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxyBase.h
index 377547a..79becb8 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxyBase.h
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxyBase.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * The interface towards the Controlling Instance (e.g HMI). It handles the
@@ -211,11 +209,11 @@ class CommandControlProxyBase: virtual public CommonAPI::Proxy {
     /**
      * This function is used to increment or decrement the current volume for a
      *  sink.
-    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
-     *  the value is not in the given volume range.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
      */
-    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep_, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
-    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep_, VolumeStepAsyncCallback callback) = 0;
+    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback) = 0;
     /**
      * sets the mute state of a sink
     (at)return E_OK on success, E_UNKNOWN on error.
@@ -264,16 +262,16 @@ class CommandControlProxyBase: virtual public CommonAPI::Proxy {
     virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback callback) = 0;
     /**
      * returns the actual list of Sources
-    (at)return E_OK on success,
-     *  E_DATABASE_ERROR on error
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
      */
     virtual void getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error) = 0;
     virtual std::future<CommonAPI::CallStatus> getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback) = 0;
     /**
      * This is used to retrieve all source sound properties related to a source.
      *  Returns a vector of the sound properties and values as pair
-    (at)return E_OK
-     *  on success, E_DATABASE_ERROR on error
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
      */
     virtual void getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) = 0;
     virtual std::future<CommonAPI::CallStatus> getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback) = 0;
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStub.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStub.h
index 6e8de18..1fe5b1a 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStub.h
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStub.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * The interface towards the Controlling Instance (e.g HMI). It handles the
@@ -204,7 +202,7 @@ class CommandControlStubRemoteEvent {
  * This class and the one above are the ones an application developer needs to have
  * a look at if he wants to implement a service.
  */
-class CommandControlStub : public virtual CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent> {
+class CommandControlStub: public virtual CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent> {
 public:
     virtual ~CommandControlStub() { }
     virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
@@ -234,11 +232,11 @@ public:
     /**
      * This function is used to increment or decrement the current volume for a
      *  sink.
-    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
-     *  the value is not in the given volume range.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
      */
     /// This is the method that will be called on remote calls on the method volumeStep.
-    virtual void volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volumeStep_, am_Error_e& error) = 0;
+    virtual void volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volStep, am_Error_e& error) = 0;
     /**
      * sets the mute state of a sink
     (at)return E_OK on success, E_UNKNOWN on error.
@@ -287,16 +285,16 @@ public:
     virtual void getListMainSinks(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SinkType_L& listMainSinks, am_Error_e& error) = 0;
     /**
      * returns the actual list of Sources
-    (at)return E_OK on success,
-     *  E_DATABASE_ERROR on error
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
      */
     /// This is the method that will be called on remote calls on the method getListMainSources.
     virtual void getListMainSources(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceType_L& listMainSources, am_Error_e& error) = 0;
     /**
      * This is used to retrieve all source sound properties related to a source.
      *  Returns a vector of the sound properties and values as pair
-    (at)return E_OK
-     *  on success, E_DATABASE_ERROR on error
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
      */
     /// This is the method that will be called on remote calls on the method getListMainSinkSoundProperties.
     virtual void getListMainSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) = 0;
@@ -483,6 +481,8 @@ public:
     using CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent>::initStubAdapter;
     typedef CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent>::StubAdapterType StubAdapterType;
     typedef CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef CommandControlStubRemoteEvent RemoteEventType;
+    typedef CommandControl StubInterface;
 };
 
 } // namespace am
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.cpp b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.cpp
index f23f2da..9f2e7c5 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.cpp
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include <org/genivi/am/CommandControlStubDefault.h>
 
@@ -70,14 +68,14 @@ void CommandControlStubDefault::setVolume(am_sinkID_t sinkID, am_mainVolume_t vo
 /**
  * This function is used to increment or decrement the current volume for a
  *  sink.
-(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
- *  the value is not in the given volume range.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
  */
-void CommandControlStubDefault::volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volumeStep_, am_Error_e& error) {
+void CommandControlStubDefault::volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volStep, am_Error_e& error) {
     // Call old style methods in default 
-    volumeStep(sinkID, volumeStep_, error);
+    volumeStep(sinkID, volStep, error);
 }
-void CommandControlStubDefault::volumeStep(am_sinkID_t sinkID, int16_t volumeStep_, am_Error_e& error) {
+void CommandControlStubDefault::volumeStep(am_sinkID_t sinkID, int16_t volStep, am_Error_e& error) {
     // No operation in default
 }
 
@@ -165,8 +163,8 @@ void CommandControlStubDefault::getListMainSinks(am_SinkType_L& listMainSinks, a
 
 /**
  * returns the actual list of Sources
-(at)return E_OK on success,
- *  E_DATABASE_ERROR on error
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
  */
 void CommandControlStubDefault::getListMainSources(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceType_L& listMainSources, am_Error_e& error) {
     // Call old style methods in default 
@@ -179,8 +177,8 @@ void CommandControlStubDefault::getListMainSources(am_SourceType_L& listMainSour
 /**
  * This is used to retrieve all source sound properties related to a source.
  *  Returns a vector of the sound properties and values as pair
-(at)return E_OK
- *  on success, E_DATABASE_ERROR on error
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
  */
 void CommandControlStubDefault::getListMainSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
     // Call old style methods in default 
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.h
index 2bfe6ba..62257a4 100644
--- a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.h
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * The interface towards the Controlling Instance (e.g HMI). It handles the
@@ -72,11 +70,11 @@ public:
     /**
      * This function is used to increment or decrement the current volume for a
      *  sink.
-    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
-     *  the value is not in the given volume range.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
      */
-    virtual void volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volumeStep_, am_Error_e& error);
-    virtual void volumeStep(am_sinkID_t sinkID, int16_t volumeStep_, am_Error_e& error);
+    virtual void volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volStep, am_Error_e& error);
+    virtual void volumeStep(am_sinkID_t sinkID, int16_t volStep, am_Error_e& error);
 
     /**
      * sets the mute state of a sink
@@ -132,8 +130,8 @@ public:
 
     /**
      * returns the actual list of Sources
-    (at)return E_OK on success,
-     *  E_DATABASE_ERROR on error
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
      */
     virtual void getListMainSources(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceType_L& listMainSources, am_Error_e& error);
     virtual void getListMainSources(am_SourceType_L& listMainSources, am_Error_e& error);
@@ -141,8 +139,8 @@ public:
     /**
      * This is used to retrieve all source sound properties related to a source.
      *  Returns a vector of the sound properties and values as pair
-    (at)return E_OK
-     *  on success, E_DATABASE_ERROR on error
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
      */
     virtual void getListMainSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
     virtual void getListMainSinkSoundProperties(am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
@@ -316,8 +314,7 @@ public:
 
 
 protected:
-private:
-    class RemoteEventHandler: public CommandControlStubRemoteEvent {
+    class RemoteEventHandler: public virtual CommandControlStubRemoteEvent {
      public:
         RemoteEventHandler(CommandControlStubDefault* defaultStub);
 
@@ -325,8 +322,8 @@ private:
      private:
         CommandControlStubDefault* defaultStub_;
     };
-
-    RemoteEventHandler remoteEventHandler_;
+private:
+    CommandControlStubDefault::RemoteEventHandler remoteEventHandler_;
 
 
     CommonAPI::Version interfaceVersion_;
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.cpp
index 161a7b7..152c8b6 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.cpp
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h
index 8996092..dced63c 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * @author Christian Linke
@@ -714,15 +712,15 @@ namespace am {
          am_NotificationStatus_e status;
         /**
          * This gives additional information to the notification status. 
-        Relation
-         *  between notification status and the value:
-        NS_PERIODIC - the period in
-         *  ms
-        NS_MINIMUM - the minimum value that triggers the notification
-        NS_MAXIMUM
-         *  - the maximum value that triggers the notifcation
-        NS_CHANGE - the resolution
-         *  of the change value
+        Relation between
+         *  notification status and the value:
+        NS_PERIODIC - the period in ms
+        NS_MINIMUM
+         *  - the minimum value that triggers the notification
+        NS_MAXIMUM - the maximum
+         *  value that triggers the notifcation
+        NS_CHANGE - the resolution of the change
+         *  value
          */
          int16_t parameter;
     
@@ -1155,8 +1153,8 @@ namespace am {
         /**
          * This enum can have 3 states:
         
-            HS_SINKA sinkA is the current hot one,
-         *  sinkB is not audible
+            HS_SINKA sinkA is the current hot one, sinkB
+         *  is not audible
             HS_SINKB sinkB is the current hot one, sinkB is not
          *  audible
             HS_INTERMEDIATE the fader is stuck in between a cross-fading
@@ -1571,11 +1569,11 @@ namespace am {
          *  tuner that is not actively heard. The source state is set by the
          *  AudioManagerController.There are 3 possible states:
         
-            SS_ON: the source
-         *  is active
+            SS_ON: the source is
+         *  active
             SS_OFF: the source is off
-            SS_PAUSED: the source is paused
-         *  and not active.
+            SS_PAUSED: the source is paused and
+         *  not active.
          */
          am_SourceState_e sourceState;
         /**
@@ -2076,7 +2074,7 @@ static inline const char* getTypeCollectionName() {
 }
 
 inline CommonAPI::Version getTypeCollectionVersion() {
-    return CommonAPI::Version(1, 0);
+    return CommonAPI::Version(2, 0);
 }
 
 } // namespace am
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControl.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControl.h
index 5cb6ccb..eba530d 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControl.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControl.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * This class implements everything from Audiomanager -&gt; RoutingAdapter
@@ -43,7 +41,7 @@ const char* RoutingControl::getInterfaceId() {
 }
 
 CommonAPI::Version RoutingControl::getInterfaceVersion() {
-    return CommonAPI::Version(1, 0);
+    return CommonAPI::Version(2, 0);
 }
 
 
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.cpp
index e32836f..24a154f 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.cpp
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * This class implements everything from Audiomanager -&gt; RoutingAdapter
@@ -27,7 +25,7 @@ std::shared_ptr<CommonAPI::DBus::DBusProxy> createRoutingControlDBusProxy(
     return std::make_shared<RoutingControlDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
 }
 
-__attribute__((constructor)) void registerRoutingControlDBusProxy(void) {
+INITIALIZER(registerRoutingControlDBusProxy) {
     CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(RoutingControl::getInterfaceId(),
        &createRoutingControlDBusProxy);
 }
@@ -72,7 +70,7 @@ std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncAbortAsync(cons
 /**
  * connects a source to a sink
 (at)return E_OK on success, E_UNKNOWN on error,
- *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
  */
 void RoutingControlDBusProxy::asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus) {
     CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_sourceID_t, am_sinkID_t, am_CustomConnectionFormat_t>,
@@ -197,8 +195,8 @@ std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSourceStateA
 }
 /**
  * this function sets the sinksoundproperty.
-(at)return E_OK on success,
- *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
 void RoutingControlDBusProxy::asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) {
     CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_SoundProperty_L>,
@@ -221,8 +219,8 @@ std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSinkSoundPro
 }
 /**
  * this function sets the sinksoundproperty.
-(at)return E_OK on success,
- *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
 void RoutingControlDBusProxy::asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) {
     CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_SoundProperty_s>,
@@ -400,7 +398,7 @@ std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSourceNotifi
 
 
 void RoutingControlDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
-    ownVersionMajor = 1;
+    ownVersionMajor = 2;
     ownVersionMinor = 0;
 }
 
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.h
index f9036d4..13557c2 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * This class implements everything from Audiomanager -&gt; RoutingAdapter
@@ -55,7 +53,7 @@ class RoutingControlDBusProxy: virtual public RoutingControlProxyBase, virtual p
     /**
      * connects a source to a sink
     (at)return E_OK on success, E_UNKNOWN on error,
-     *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
      */
     virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus);
     virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, AsyncConnectAsyncCallback callback);
@@ -95,15 +93,15 @@ class RoutingControlDBusProxy: virtual public RoutingControlProxyBase, virtual p
     virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback);
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      */
     virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback);
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      */
     virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback);
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.cpp
index 8563781..2016a98 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.cpp
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include "RoutingControlDBusStubAdapter.h"
 #include <org/genivi/am/RoutingControl.h>
@@ -25,7 +23,7 @@ std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createRoutingControlDBusStubAd
     return std::make_shared<RoutingControlDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
 }
 
-__attribute__((constructor)) void registerRoutingControlDBusStubAdapter(void) {
+INITIALIZER(registerRoutingControlDBusStubAdapter) {
     CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(RoutingControl::getInterfaceId(),
                                                                &createRoutingControlDBusStubAdapter);
 }
@@ -38,6 +36,7 @@ RoutingControlDBusStubAdapterInternal::~RoutingControlDBusStubAdapterInternal()
 }
 
 void RoutingControlDBusStubAdapterInternal::deactivateManagedInstances() {
+
 }
 
 const char* RoutingControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
@@ -56,7 +55,7 @@ const char* RoutingControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXm
         /**
          * connects a source to a sink
         (at)return E_OK on success, E_UNKNOWN on error,
-         *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+         *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
          */
         "<method name=\"asyncConnect\">\n"
             "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
@@ -116,8 +115,8 @@ const char* RoutingControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXm
         "</method>\n"
         /**
          * this function sets the sinksoundproperty.
-        (at)return E_OK on success,
-         *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+        (at)return E_OK on success, E_UNKNOWN
+         *  on error, E_OUT_OF_RANGE in case the propery value is out of range
          */
         "<method name=\"asyncSetSinkSoundProperties\">\n"
             "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
@@ -126,8 +125,8 @@ const char* RoutingControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXm
         "</method>\n"
         /**
          * this function sets the sinksoundproperty.
-        (at)return E_OK on success,
-         *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+        (at)return E_OK on success, E_UNKNOWN
+         *  on error, E_OUT_OF_RANGE in case the propery value is out of range
          */
         "<method name=\"asyncSetSinkSoundProperty\">\n"
             "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
@@ -195,10 +194,11 @@ const char* RoutingControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXm
     return introspectionData.c_str();
 }
 
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         RoutingControlStub,
         CommonAPI::Version
-        > getRoutingControlInterfaceVersionStubDispatcher(&RoutingControlStub::getInterfaceVersion, "uu");
+        > RoutingControlDBusStubAdapterInternal::getRoutingControlInterfaceVersionStubDispatcher(&RoutingControlStub::getInterfaceVersion, "uu");
+
 
 
 /**
@@ -206,31 +206,31 @@ static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
 (at)return E_OK on success, E_UNKNOWN on error,
  *  E_NON_EXISTENT if handle was not found
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s>,
     std::tuple<>
-    > asyncAbortStubDispatcher(&RoutingControlStub::asyncAbort, "");
+    > RoutingControlDBusStubAdapterInternal::asyncAbortStubDispatcher(&RoutingControlStub::asyncAbort, "");
 /**
  * connects a source to a sink
 (at)return E_OK on success, E_UNKNOWN on error,
- *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_connectionID_t, am_sourceID_t, am_sinkID_t, am_CustomConnectionFormat_t>,
     std::tuple<>
-    > asyncConnectStubDispatcher(&RoutingControlStub::asyncConnect, "");
+    > RoutingControlDBusStubAdapterInternal::asyncConnectStubDispatcher(&RoutingControlStub::asyncConnect, "");
 /**
  * disconnect a connection with given connectionID
 (at)return E_OK on success,
  *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_connectionID_t>,
     std::tuple<>
-    > asyncDisconnectStubDispatcher(&RoutingControlStub::asyncDisconnect, "");
+    > RoutingControlDBusStubAdapterInternal::asyncDisconnectStubDispatcher(&RoutingControlStub::asyncDisconnect, "");
 /**
  * this method is used to set the volume of a sink. This function is used to drive
  *  ramps, to mute or unmute or directly set the value. The difference is made
@@ -238,11 +238,11 @@ static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
 (at)return E_OK on success, E_UNKNOWN on error,
  *  E_OUT_OF_RANGE if new volume is out of range
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sinkID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
     std::tuple<>
-    > asyncSetSinkVolumeStubDispatcher(&RoutingControlStub::asyncSetSinkVolume, "");
+    > RoutingControlDBusStubAdapterInternal::asyncSetSinkVolumeStubDispatcher(&RoutingControlStub::asyncSetSinkVolume, "");
 /**
  * sets the volume of a source. This method is used to set the volume of a sink.
  *  This function is used to drive ramps, to mute or unmute or directly set the
@@ -252,96 +252,98 @@ static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
  *  range.
 triggers the acknowledge ackSourceVolumeChange
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sourceID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
     std::tuple<>
-    > asyncSetSourceVolumeStubDispatcher(&RoutingControlStub::asyncSetSourceVolume, "");
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceVolumeStubDispatcher(&RoutingControlStub::asyncSetSourceVolume, "");
 /**
  * This function is used to set the source state of a particular
  *  source.
 (at)return E_OK on success, E_UNKNOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sourceID_t, am_SourceState_e>,
     std::tuple<>
-    > asyncSetSourceStateStubDispatcher(&RoutingControlStub::asyncSetSourceState, "");
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceStateStubDispatcher(&RoutingControlStub::asyncSetSourceState, "");
 /**
  * this function sets the sinksoundproperty.
-(at)return E_OK on success,
- *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_L>,
     std::tuple<>
-    > asyncSetSinkSoundPropertiesStubDispatcher(&RoutingControlStub::asyncSetSinkSoundProperties, "");
+    > RoutingControlDBusStubAdapterInternal::asyncSetSinkSoundPropertiesStubDispatcher(&RoutingControlStub::asyncSetSinkSoundProperties, "");
 /**
  * this function sets the sinksoundproperty.
-(at)return E_OK on success,
- *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_s>,
     std::tuple<>
-    > asyncSetSinkSoundPropertyStubDispatcher(&RoutingControlStub::asyncSetSinkSoundProperty, "");
+    > RoutingControlDBusStubAdapterInternal::asyncSetSinkSoundPropertyStubDispatcher(&RoutingControlStub::asyncSetSinkSoundProperty, "");
 /**
  * this function sets the sourcesoundproperty.
 (at)return E_OK on success,
  *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_L>,
     std::tuple<>
-    > asyncSetSourceSoundPropertiesStubDispatcher(&RoutingControlStub::asyncSetSourceSoundProperties, "");
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceSoundPropertiesStubDispatcher(&RoutingControlStub::asyncSetSourceSoundProperties, "");
 /**
  * this function sets the sourcesoundproperty.
 (at)return E_OK on success,
  *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_s>,
     std::tuple<>
-    > asyncSetSourceSoundPropertyStubDispatcher(&RoutingControlStub::asyncSetSourceSoundProperty, "");
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceSoundPropertyStubDispatcher(&RoutingControlStub::asyncSetSourceSoundProperty, "");
 /**
  * this function triggers crossfading.
 (at)return E_OK on success, E_UNKNOWN on
  *  error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_crossfaderID_t, am_HotSink_e, am_CustomRampType_t, am_time_t>,
     std::tuple<>
-    > asyncCrossFadeStubDispatcher(&RoutingControlStub::asyncCrossFade, "");
+    > RoutingControlDBusStubAdapterInternal::asyncCrossFadeStubDispatcher(&RoutingControlStub::asyncCrossFade, "");
 /**
  * this function is used for early and late audio functions to set the domain
  *  state
 (at)return E_OK on success, E_UNKNOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_domainID_t, am_DomainState_e>,
     std::tuple<am_Error_e>
-    > setDomainStateStubDispatcher(&RoutingControlStub::setDomainState, "i");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > RoutingControlDBusStubAdapterInternal::setDomainStateStubDispatcher(&RoutingControlStub::setDomainState, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_Volumes_L>,
     std::tuple<>
-    > asyncSetVolumesStubDispatcher(&RoutingControlStub::asyncSetVolumes, "");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > RoutingControlDBusStubAdapterInternal::asyncSetVolumesStubDispatcher(&RoutingControlStub::asyncSetVolumes, "");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sinkID_t, am_NotificationConfiguration_s>,
     std::tuple<>
-    > asyncSetSinkNotificationConfigurationStubDispatcher(&RoutingControlStub::asyncSetSinkNotificationConfiguration, "");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > RoutingControlDBusStubAdapterInternal::asyncSetSinkNotificationConfigurationStubDispatcher(&RoutingControlStub::asyncSetSinkNotificationConfiguration, "");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlStub,
     std::tuple<am_Handle_s, am_sourceID_t, am_NotificationConfiguration_s>,
     std::tuple<>
-    > asyncSetSourceNotificationConfigurationStubDispatcher(&RoutingControlStub::asyncSetSourceNotificationConfiguration, "");
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceNotificationConfigurationStubDispatcher(&RoutingControlStub::asyncSetSourceNotificationConfiguration, "");
+
+
 
 
 
@@ -349,6 +351,9 @@ const RoutingControlDBusStubAdapterHelper::StubDispatcherTable& RoutingControlDB
     return stubDispatcherTable_;
 }
 
+const CommonAPI::DBus::StubAttributeTable& RoutingControlDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
 
 RoutingControlDBusStubAdapterInternal::RoutingControlDBusStubAdapterInternal(
         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -381,19 +386,19 @@ RoutingControlDBusStubAdapterInternal::RoutingControlDBusStubAdapterInternal(
             (at)return E_OK on success, E_UNKNOWN on error,
              *  E_NON_EXISTENT if handle was not found
              */
-            { { "asyncAbort", "(iq)" }, &org::genivi::am::asyncAbortStubDispatcher },
+            { { "asyncAbort", "(iq)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncAbortStubDispatcher },
             /**
              * connects a source to a sink
             (at)return E_OK on success, E_UNKNOWN on error,
-             *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+             *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
              */
-            { { "asyncConnect", "(iq)qqqq" }, &org::genivi::am::asyncConnectStubDispatcher },
+            { { "asyncConnect", "(iq)qqqq" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncConnectStubDispatcher },
             /**
              * disconnect a connection with given connectionID
             (at)return E_OK on success,
              *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
              */
-            { { "asyncDisconnect", "(iq)q" }, &org::genivi::am::asyncDisconnectStubDispatcher },
+            { { "asyncDisconnect", "(iq)q" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncDisconnectStubDispatcher },
             /**
              * this method is used to set the volume of a sink. This function is used to drive
              *  ramps, to mute or unmute or directly set the value. The difference is made
@@ -401,7 +406,7 @@ RoutingControlDBusStubAdapterInternal::RoutingControlDBusStubAdapterInternal(
             (at)return E_OK on success, E_UNKNOWN on error,
              *  E_OUT_OF_RANGE if new volume is out of range
              */
-            { { "asyncSetSinkVolume", "(iq)qnqn" }, &org::genivi::am::asyncSetSinkVolumeStubDispatcher },
+            { { "asyncSetSinkVolume", "(iq)qnqn" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSinkVolumeStubDispatcher },
             /**
              * sets the volume of a source. This method is used to set the volume of a sink.
              *  This function is used to drive ramps, to mute or unmute or directly set the
@@ -411,55 +416,60 @@ RoutingControlDBusStubAdapterInternal::RoutingControlDBusStubAdapterInternal(
              *  range.
             triggers the acknowledge ackSourceVolumeChange
              */
-            { { "asyncSetSourceVolume", "(iq)qnqn" }, &org::genivi::am::asyncSetSourceVolumeStubDispatcher },
+            { { "asyncSetSourceVolume", "(iq)qnqn" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceVolumeStubDispatcher },
             /**
              * This function is used to set the source state of a particular
              *  source.
             (at)return E_OK on success, E_UNKNOWN on error
              */
-            { { "asyncSetSourceState", "(iq)qi" }, &org::genivi::am::asyncSetSourceStateStubDispatcher },
+            { { "asyncSetSourceState", "(iq)qi" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceStateStubDispatcher },
             /**
              * this function sets the sinksoundproperty.
-            (at)return E_OK on success,
-             *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+            (at)return E_OK on success, E_UNKNOWN
+             *  on error, E_OUT_OF_RANGE in case the propery value is out of range
              */
-            { { "asyncSetSinkSoundProperties", "(iq)qa(qn)" }, &org::genivi::am::asyncSetSinkSoundPropertiesStubDispatcher },
+            { { "asyncSetSinkSoundProperties", "(iq)qa(qn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSinkSoundPropertiesStubDispatcher },
             /**
              * this function sets the sinksoundproperty.
-            (at)return E_OK on success,
-             *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+            (at)return E_OK on success, E_UNKNOWN
+             *  on error, E_OUT_OF_RANGE in case the propery value is out of range
              */
-            { { "asyncSetSinkSoundProperty", "(iq)q(qn)" }, &org::genivi::am::asyncSetSinkSoundPropertyStubDispatcher },
+            { { "asyncSetSinkSoundProperty", "(iq)q(qn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSinkSoundPropertyStubDispatcher },
             /**
              * this function sets the sourcesoundproperty.
             (at)return E_OK on success,
              *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
              */
-            { { "asyncSetSourceSoundProperties", "(iq)qa(qn)" }, &org::genivi::am::asyncSetSourceSoundPropertiesStubDispatcher },
+            { { "asyncSetSourceSoundProperties", "(iq)qa(qn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceSoundPropertiesStubDispatcher },
             /**
              * this function sets the sourcesoundproperty.
             (at)return E_OK on success,
              *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
              */
-            { { "asyncSetSourceSoundProperty", "(iq)q(qn)" }, &org::genivi::am::asyncSetSourceSoundPropertyStubDispatcher },
+            { { "asyncSetSourceSoundProperty", "(iq)q(qn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceSoundPropertyStubDispatcher },
             /**
              * this function triggers crossfading.
             (at)return E_OK on success, E_UNKNOWN on
              *  error
              */
-            { { "asyncCrossFade", "(iq)qiqn" }, &org::genivi::am::asyncCrossFadeStubDispatcher },
+            { { "asyncCrossFade", "(iq)qiqn" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncCrossFadeStubDispatcher },
             /**
              * this function is used for early and late audio functions to set the domain
              *  state
             (at)return E_OK on success, E_UNKNOWN on error
              */
-            { { "setDomainState", "qi" }, &org::genivi::am::setDomainStateStubDispatcher },
-            { { "asyncSetVolumes", "(iq)a(i(yv)nqn)" }, &org::genivi::am::asyncSetVolumesStubDispatcher },
-            { { "asyncSetSinkNotificationConfiguration", "(iq)q(qin)" }, &org::genivi::am::asyncSetSinkNotificationConfigurationStubDispatcher },
-            { { "asyncSetSourceNotificationConfiguration", "(iq)q(qin)" }, &org::genivi::am::asyncSetSourceNotificationConfigurationStubDispatcher }
-            }) {
+            { { "setDomainState", "qi" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::setDomainStateStubDispatcher },
+            { { "asyncSetVolumes", "(iq)a(i(yv)nqn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetVolumesStubDispatcher },
+            { { "asyncSetSinkNotificationConfiguration", "(iq)q(qin)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSinkNotificationConfigurationStubDispatcher },
+            { { "asyncSetSourceNotificationConfiguration", "(iq)q(qin)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceNotificationConfigurationStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::getRoutingControlInterfaceVersionStubDispatcher });
+}
 
-    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::getRoutingControlInterfaceVersionStubDispatcher });
+const bool RoutingControlDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
 }
 
 } // namespace am
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.h
index 5f73bcb..4be03fd 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * This class implements everything from Audiomanager -&gt; RoutingAdapter
@@ -33,7 +31,7 @@ namespace am {
 
 typedef CommonAPI::DBus::DBusStubAdapterHelper<RoutingControlStub> RoutingControlDBusStubAdapterHelper;
 
-class RoutingControlDBusStubAdapterInternal: public RoutingControlStubAdapter, public RoutingControlDBusStubAdapterHelper {
+class RoutingControlDBusStubAdapterInternal: public virtual RoutingControlStubAdapter, public RoutingControlDBusStubAdapterHelper {
  public:
     RoutingControlDBusStubAdapterInternal(
             const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -46,19 +44,175 @@ class RoutingControlDBusStubAdapterInternal: public RoutingControlStubAdapter, p
 
     ~RoutingControlDBusStubAdapterInternal();
 
+    virtual const bool hasFreedesktopProperties();
+
 
 
 
     const RoutingControlDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
 
     void deactivateManagedInstances();
 
 
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlStub,
+        CommonAPI::Version
+        > getRoutingControlInterfaceVersionStubDispatcher;
+
+
+
+/**
+ * aborts an asynchronous action.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_NON_EXISTENT if handle was not found
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s>,
+    std::tuple<>
+    > asyncAbortStubDispatcher;
+/**
+ * connects a source to a sink
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_sourceID_t, am_sinkID_t, am_CustomConnectionFormat_t>,
+    std::tuple<>
+    > asyncConnectStubDispatcher;
+/**
+ * disconnect a connection with given connectionID
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_connectionID_t>,
+    std::tuple<>
+    > asyncDisconnectStubDispatcher;
+/**
+ * this method is used to set the volume of a sink. This function is used to drive
+ *  ramps, to mute or unmute or directly set the value. The difference is made
+ *  through the ramptype.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_OUT_OF_RANGE if new volume is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > asyncSetSinkVolumeStubDispatcher;
+/**
+ * sets the volume of a source. This method is used to set the volume of a sink.
+ *  This function is used to drive ramps, to mute or unmute or directly set the
+ *  value. The difference is made through the ramptype.
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+ *  range.
+triggers the acknowledge ackSourceVolumeChange
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > asyncSetSourceVolumeStubDispatcher;
+/**
+ * This function is used to set the source state of a particular
+ *  source.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SourceState_e>,
+    std::tuple<>
+    > asyncSetSourceStateStubDispatcher;
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_L>,
+    std::tuple<>
+    > asyncSetSinkSoundPropertiesStubDispatcher;
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_s>,
+    std::tuple<>
+    > asyncSetSinkSoundPropertyStubDispatcher;
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_L>,
+    std::tuple<>
+    > asyncSetSourceSoundPropertiesStubDispatcher;
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_s>,
+    std::tuple<>
+    > asyncSetSourceSoundPropertyStubDispatcher;
+/**
+ * this function triggers crossfading.
+(at)return E_OK on success, E_UNKNOWN on
+ *  error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_crossfaderID_t, am_HotSink_e, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > asyncCrossFadeStubDispatcher;
+/**
+ * this function is used for early and late audio functions to set the domain
+ *  state
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_domainID_t, am_DomainState_e>,
+    std::tuple<am_Error_e>
+    > setDomainStateStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_Volumes_L>,
+    std::tuple<>
+    > asyncSetVolumesStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_NotificationConfiguration_s>,
+    std::tuple<>
+    > asyncSetSinkNotificationConfigurationStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_NotificationConfiguration_s>,
+    std::tuple<>
+    > asyncSetSourceNotificationConfigurationStubDispatcher;
+
+
+
+
  protected:
     virtual const char* getMethodsDBusIntrospectionXmlData() const;
-    
-  private:
+
+ private:
     RoutingControlDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
 };
 
 class RoutingControlDBusStubAdapter: public RoutingControlDBusStubAdapterInternal, public std::enable_shared_from_this<RoutingControlDBusStubAdapter> {
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserver.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserver.h
index 4fe3ad8..cb3508e 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserver.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserver.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * Routing Receive sendInterface description.
@@ -43,7 +41,7 @@ const char* RoutingControlObserver::getInterfaceId() {
 }
 
 CommonAPI::Version RoutingControlObserver::getInterfaceVersion() {
-    return CommonAPI::Version(0, 1);
+    return CommonAPI::Version(2, 0);
 }
 
 
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.cpp
index 9da10db..5d5d5d4 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.cpp
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * Routing Receive sendInterface description.
@@ -27,7 +25,7 @@ std::shared_ptr<CommonAPI::DBus::DBusProxy> createRoutingControlObserverDBusProx
     return std::make_shared<RoutingControlObserverDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
 }
 
-__attribute__((constructor)) void registerRoutingControlObserverDBusProxy(void) {
+INITIALIZER(registerRoutingControlObserverDBusProxy) {
     CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(RoutingControlObserver::getInterfaceId(),
        &createRoutingControlObserverDBusProxy);
 }
@@ -320,8 +318,8 @@ std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSinkVolum
  *  registered with this name, it will return the corresponding ID, if not it will
  *  reserve an ID but not register the domain. The other parameters of the domain
  *  will be overwritten when the domain is registered.
-(at)return E_OK on
- *  success, E_UNKNOWN on error
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
  */
 void RoutingControlObserverDBusProxy::peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
     CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
@@ -520,8 +518,8 @@ std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterSi
  *  registered with this name, it will return the corresponding ID, if not it will
  *  reserve an ID but not register the source. The other parameters of the source
  *  will be overwritten when the source is registered.
-(at)return E_OK on
- *  success, E_UNKNOWN on error
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
  */
 void RoutingControlObserverDBusProxy::peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
     CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
@@ -898,8 +896,8 @@ std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateSinkAs
 /**
  * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
  *  sourceID in the struct is not valid. 
-Please note that only the following
- *  data out of am_Source_s have effect when they are
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
  *  changed:
 sourceClassID,
 listSoundProperties,
@@ -1059,8 +1057,8 @@ std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::confirmRouti
 
 
 void RoutingControlObserverDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
-    ownVersionMajor = 0;
-    ownVersionMinor = 1;
+    ownVersionMajor = 2;
+    ownVersionMinor = 0;
 }
 
 } // namespace am
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.h
index 81d8885..a5d7f3c 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * Routing Receive sendInterface description.
@@ -114,8 +112,8 @@ class RoutingControlObserverDBusProxy: virtual public RoutingControlObserverProx
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the domain. The other parameters of the domain
      *  will be overwritten when the domain is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      */
     virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
     virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback);
@@ -178,8 +176,8 @@ class RoutingControlObserverDBusProxy: virtual public RoutingControlObserverProx
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the source. The other parameters of the source
      *  will be overwritten when the source is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      */
     virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
     virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback);
@@ -284,8 +282,8 @@ class RoutingControlObserverDBusProxy: virtual public RoutingControlObserverProx
     /**
      * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
      *  sourceID in the struct is not valid. 
-    Please note that only the following
-     *  data out of am_Source_s have effect when they are
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
      *  changed:
     sourceClassID,
     listSoundProperties,
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.cpp
index 4c8053d..00f4565 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.cpp
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include "RoutingControlObserverDBusStubAdapter.h"
 #include <org/genivi/am/RoutingControlObserver.h>
@@ -25,7 +23,7 @@ std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createRoutingControlObserverDB
     return std::make_shared<RoutingControlObserverDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
 }
 
-__attribute__((constructor)) void registerRoutingControlObserverDBusStubAdapter(void) {
+INITIALIZER(registerRoutingControlObserverDBusStubAdapter) {
     CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(RoutingControlObserver::getInterfaceId(),
                                                                &createRoutingControlObserverDBusStubAdapter);
 }
@@ -38,6 +36,7 @@ RoutingControlObserverDBusStubAdapterInternal::~RoutingControlObserverDBusStubAd
 }
 
 void RoutingControlObserverDBusStubAdapterInternal::deactivateManagedInstances() {
+
 }
 
 const char* RoutingControlObserverDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
@@ -149,8 +148,8 @@ const char* RoutingControlObserverDBusStubAdapterInternal::getMethodsDBusIntrosp
          *  registered with this name, it will return the corresponding ID, if not it will
          *  reserve an ID but not register the domain. The other parameters of the domain
          *  will be overwritten when the domain is registered.
-        (at)return E_OK on
-         *  success, E_UNKNOWN on error
+        (at)return E_OK on success,
+         *  E_UNKNOWN on error
          */
         "<method name=\"peekDomain\">\n"
             "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
@@ -236,8 +235,8 @@ const char* RoutingControlObserverDBusStubAdapterInternal::getMethodsDBusIntrosp
          *  registered with this name, it will return the corresponding ID, if not it will
          *  reserve an ID but not register the source. The other parameters of the source
          *  will be overwritten when the source is registered.
-        (at)return E_OK on
-         *  success, E_UNKNOWN on error
+        (at)return E_OK on success,
+         *  E_UNKNOWN on error
          */
         "<method name=\"peekSource\">\n"
             "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
@@ -384,8 +383,8 @@ const char* RoutingControlObserverDBusStubAdapterInternal::getMethodsDBusIntrosp
         /**
          * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
          *  sourceID in the struct is not valid. 
-        Please note that only the following
-         *  data out of am_Source_s have effect when they are
+        Please note that only the following data
+         *  out of am_Source_s have effect when they are
          *  changed:
         sourceClassID,
         listSoundProperties,
@@ -445,10 +444,10 @@ const char* RoutingControlObserverDBusStubAdapterInternal::getMethodsDBusIntrosp
     return introspectionData.c_str();
 }
 
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         RoutingControlObserverStub,
         CommonAPI::Version
-        > getRoutingControlObserverInterfaceVersionStubDispatcher(&RoutingControlObserverStub::getInterfaceVersion, "uu");
+        > RoutingControlObserverDBusStubAdapterInternal::getRoutingControlObserverInterfaceVersionStubDispatcher(&RoutingControlObserverStub::getInterfaceVersion, "uu");
 
 /**
  * This attribute signals to the clients the current routing state.
@@ -456,164 +455,164 @@ A client
  *  should notify himself to this attribute in order to know the current state and
  *  act accordingly.
  */
-static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
         RoutingControlObserverStub,
         am_RoutingReady_e
-        > getRoutingReadyAttributeStubDispatcher(&RoutingControlObserverStub::getRoutingReadyAttribute, "i");
+        > RoutingControlObserverDBusStubAdapterInternal::getRoutingReadyAttributeStubDispatcher(&RoutingControlObserverStub::getRoutingReadyAttribute, "i");
 
 
 /**
  * acknowledges a asyncConnect
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
     std::tuple<>
-    > ackConnectStubDispatcher(&RoutingControlObserverStub::ackConnect, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackConnectStubDispatcher(&RoutingControlObserverStub::ackConnect, "");
 /**
  * acknowledges a asyncDisconnect
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
     std::tuple<>
-    > ackDisconnectStubDispatcher(&RoutingControlObserverStub::ackDisconnect, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackDisconnectStubDispatcher(&RoutingControlObserverStub::ackDisconnect, "");
 /**
  * acknowledges a asyncsetSinkVolume
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
     std::tuple<>
-    > ackSetSinkVolumeChangeStubDispatcher(&RoutingControlObserverStub::ackSetSinkVolumeChange, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSinkVolumeChangeStubDispatcher(&RoutingControlObserverStub::ackSetSinkVolumeChange, "");
 /**
  * acknowledges a asyncsetSourceVolume
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
     std::tuple<>
-    > ackSetSourceVolumeChangeStubDispatcher(&RoutingControlObserverStub::ackSetSourceVolumeChange, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSourceVolumeChangeStubDispatcher(&RoutingControlObserverStub::ackSetSourceVolumeChange, "");
 /**
  * acknowlegde for asyncSetSourceState
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_Error_e>,
     std::tuple<>
-    > ackSetSourceStateStubDispatcher(&RoutingControlObserverStub::ackSetSourceState, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSourceStateStubDispatcher(&RoutingControlObserverStub::ackSetSourceState, "");
 /**
  * acknowledges asyncSetSinkSoundProperties
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_Error_e>,
     std::tuple<>
-    > ackSetSinkSoundPropertiesStubDispatcher(&RoutingControlObserverStub::ackSetSinkSoundProperties, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSinkSoundPropertiesStubDispatcher(&RoutingControlObserverStub::ackSetSinkSoundProperties, "");
 /**
  * acknowledges asyncSetSinkSoundProperty
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_Error_e>,
     std::tuple<>
-    > ackSetSinkSoundPropertyStubDispatcher(&RoutingControlObserverStub::ackSetSinkSoundProperty, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSinkSoundPropertyStubDispatcher(&RoutingControlObserverStub::ackSetSinkSoundProperty, "");
 /**
  * acknowledges asyncSetSourceSoundProperties
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_Error_e>,
     std::tuple<>
-    > ackSetSourceSoundPropertiesStubDispatcher(&RoutingControlObserverStub::ackSetSourceSoundProperties, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSourceSoundPropertiesStubDispatcher(&RoutingControlObserverStub::ackSetSourceSoundProperties, "");
 /**
  * acknowledges asyncSetSourceSoundProperty
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_Error_e>,
     std::tuple<>
-    > ackSetSourceSoundPropertyStubDispatcher(&RoutingControlObserverStub::ackSetSourceSoundProperty, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSourceSoundPropertyStubDispatcher(&RoutingControlObserverStub::ackSetSourceSoundProperty, "");
 /**
  * acknowledges asyncCrossFade
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_HotSink_e, am_Error_e>,
     std::tuple<>
-    > ackCrossFadingStubDispatcher(&RoutingControlObserverStub::ackCrossFading, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackCrossFadingStubDispatcher(&RoutingControlObserverStub::ackCrossFading, "");
 /**
  * acknowledges a volume tick. This can be used to display volumechanges during
  *  ramps
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_sourceID_t, am_volume_t>,
     std::tuple<>
-    > ackSourceVolumeTickStubDispatcher(&RoutingControlObserverStub::ackSourceVolumeTick, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSourceVolumeTickStubDispatcher(&RoutingControlObserverStub::ackSourceVolumeTick, "");
 /**
  * acknowledges a volume tick. This can be used to display volumechanges during
  *  ramps
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_sinkID_t, am_volume_t>,
     std::tuple<>
-    > ackSinkVolumeTickStubDispatcher(&RoutingControlObserverStub::ackSinkVolumeTick, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSinkVolumeTickStubDispatcher(&RoutingControlObserverStub::ackSinkVolumeTick, "");
 /**
  * This function returns the ID to the given domainName. If already a domain is
  *  registered with this name, it will return the corresponding ID, if not it will
  *  reserve an ID but not register the domain. The other parameters of the domain
  *  will be overwritten when the domain is registered.
-(at)return E_OK on
- *  success, E_UNKNOWN on error
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<std::string>,
     std::tuple<am_domainID_t, am_Error_e>
-    > peekDomainStubDispatcher(&RoutingControlObserverStub::peekDomain, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::peekDomainStubDispatcher(&RoutingControlObserverStub::peekDomain, "qi");
 /**
  * registers a domain
 (at)return E_OK on succes, E_ALREADY_EXISTENT if already
  *  registered E_UNKOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Domain_s, std::string, std::string>,
     std::tuple<am_domainID_t, am_Error_e>
-    > registerDomainStubDispatcher(&RoutingControlObserverStub::registerDomain, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::registerDomainStubDispatcher(&RoutingControlObserverStub::registerDomain, "qi");
 /**
  * deregisters a domain. All sources, sinks, gateways and crossfaders from that
  *  domain will be removed as well.
 (at)return E_OK on succes, E_NON_EXISTENT if
  *  not found E_UNKOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_domainID_t>,
     std::tuple<am_Error_e>
-    > deregisterDomainStubDispatcher(&RoutingControlObserverStub::deregisterDomain, "i");
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterDomainStubDispatcher(&RoutingControlObserverStub::deregisterDomain, "i");
 /**
  * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
  *  registered E_UNKOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Gateway_s>,
     std::tuple<am_gatewayID_t, am_Error_e>
-    > registerGatewayStubDispatcher(&RoutingControlObserverStub::registerGateway, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::registerGatewayStubDispatcher(&RoutingControlObserverStub::registerGateway, "qi");
 /**
  * deregisters a gateway. Also removes all sinks and sources of the controlling
  *  domain.
 (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
  *  error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_gatewayID_t>,
     std::tuple<am_Error_e>
-    > deregisterGatewayStubDispatcher(&RoutingControlObserverStub::deregisterGateway, "i");
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterGatewayStubDispatcher(&RoutingControlObserverStub::deregisterGateway, "i");
 /**
  * This function returns the ID to the given sinkName. If already a sink is
  *  registered with this name, it will return the corresponding ID, if not it will
@@ -622,45 +621,45 @@ static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
 (at)return E_OK on success,
  *  E_UNKNOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<std::string>,
     std::tuple<am_sinkID_t, am_Error_e>
-    > peekSinkStubDispatcher(&RoutingControlObserverStub::peekSink, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::peekSinkStubDispatcher(&RoutingControlObserverStub::peekSink, "qi");
 /**
  * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
  *  is copied to the gatewayInformation
 (at)return E_OK on succes,
  *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Sink_s>,
     std::tuple<am_sinkID_t, am_Error_e>
-    > registerSinkStubDispatcher(&RoutingControlObserverStub::registerSink, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::registerSinkStubDispatcher(&RoutingControlObserverStub::registerSink, "qi");
 /**
  * deregisters a sink.
 (at)return E_OK on succes, E_NON_EXISTENT if not found
  *  E_UNKOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sinkID_t>,
     std::tuple<am_Error_e>
-    > deregisterSinkStubDispatcher(&RoutingControlObserverStub::deregisterSink, "i");
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterSinkStubDispatcher(&RoutingControlObserverStub::deregisterSink, "i");
 /**
  * This function returns the ID to the given sourceName. If already a source is
  *  registered with this name, it will return the corresponding ID, if not it will
  *  reserve an ID but not register the source. The other parameters of the source
  *  will be overwritten when the source is registered.
-(at)return E_OK on
- *  success, E_UNKNOWN on error
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<std::string>,
     std::tuple<am_sourceID_t, am_Error_e>
-    > peekSourceStubDispatcher(&RoutingControlObserverStub::peekSource, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::peekSourceStubDispatcher(&RoutingControlObserverStub::peekSource, "qi");
 /**
  * registers a source.  If the source is part of a gateway, the
  *  listconnectionFormats is copied to the gatewayInformation
@@ -668,147 +667,147 @@ static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
  *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
  *  already exists
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Source_s>,
     std::tuple<am_sourceID_t, am_Error_e>
-    > registerSourceStubDispatcher(&RoutingControlObserverStub::registerSource, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::registerSourceStubDispatcher(&RoutingControlObserverStub::registerSource, "qi");
 /**
  * deregisters a source
 (at)return E_OK on succes, E_NON_EXISTENT if not found
  *  E_UNKOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sourceID_t>,
     std::tuple<am_Error_e>
-    > deregisterSourceStubDispatcher(&RoutingControlObserverStub::deregisterSource, "i");
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterSourceStubDispatcher(&RoutingControlObserverStub::deregisterSource, "i");
 /**
  * this function registers a crossfader.
 (at)return E_OK on succes,
  *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Crossfader_s>,
     std::tuple<am_crossfaderID_t, am_Error_e>
-    > registerCrossfaderStubDispatcher(&RoutingControlObserverStub::registerCrossfader, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::registerCrossfaderStubDispatcher(&RoutingControlObserverStub::registerCrossfader, "qi");
 /**
  * this function deregisters a crossfader. removes all sources and sinks assiated
  *  as well.
 (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
  *  error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_crossfaderID_t>,
     std::tuple<am_Error_e>
-    > deregisterCrossfaderStubDispatcher(&RoutingControlObserverStub::deregisterCrossfader, "i");
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterCrossfaderStubDispatcher(&RoutingControlObserverStub::deregisterCrossfader, "i");
 /**
  * this function peeks a sourceclassID. It is used by the RoutingPlugins to
  *  determine the SinkClassIDs of a sinkClass.
 (at)return E_OK on succes,
  *  E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<std::string>,
     std::tuple<am_sourceClass_t, am_Error_e>
-    > peekSourceClassIDStubDispatcher(&RoutingControlObserverStub::peekSourceClassID, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::peekSourceClassIDStubDispatcher(&RoutingControlObserverStub::peekSourceClassID, "qi");
 /**
  * this function peeks a sourceclassID. It is used by the RoutingPlugins to
  *  determine the SinkClassIDs of a sinkClass.
 (at)return E_OK on succes,
  *  E_DATABASE_ERROR on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<std::string>,
     std::tuple<am_sinkClass_t, am_Error_e>
-    > peekSinkClassIDStubDispatcher(&RoutingControlObserverStub::peekSinkClassID, "qi");
+    > RoutingControlObserverDBusStubAdapterInternal::peekSinkClassIDStubDispatcher(&RoutingControlObserverStub::peekSinkClassID, "qi");
 /**
  * is called when a low level interrupt changes it status.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sourceID_t, am_InterruptState_e>,
     std::tuple<>
-    > hookInterruptStatusChangeStubDispatcher(&RoutingControlObserverStub::hookInterruptStatusChange, "");
+    > RoutingControlObserverDBusStubAdapterInternal::hookInterruptStatusChangeStubDispatcher(&RoutingControlObserverStub::hookInterruptStatusChange, "");
 /**
  * This hook is called when all elements from a domain are registered.
 Is used by
  *  the Controller to know when all expected domains are finally registered
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_domainID_t>,
     std::tuple<>
-    > hookDomainRegistrationCompleteStubDispatcher(&RoutingControlObserverStub::hookDomainRegistrationComplete, "");
+    > RoutingControlObserverDBusStubAdapterInternal::hookDomainRegistrationCompleteStubDispatcher(&RoutingControlObserverStub::hookDomainRegistrationComplete, "");
 /**
  * is called when a sink changes its availability
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sinkID_t, am_Availability_s>,
     std::tuple<>
-    > hookSinkAvailablityStatusChangeStubDispatcher(&RoutingControlObserverStub::hookSinkAvailablityStatusChange, "");
+    > RoutingControlObserverDBusStubAdapterInternal::hookSinkAvailablityStatusChangeStubDispatcher(&RoutingControlObserverStub::hookSinkAvailablityStatusChange, "");
 /**
  * is called when a source changes its availability
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sourceID_t, am_Availability_s>,
     std::tuple<>
-    > hookSourceAvailablityStatusChangeStubDispatcher(&RoutingControlObserverStub::hookSourceAvailablityStatusChange, "");
+    > RoutingControlObserverDBusStubAdapterInternal::hookSourceAvailablityStatusChangeStubDispatcher(&RoutingControlObserverStub::hookSourceAvailablityStatusChange, "");
 /**
  * is called when a domain changes its status. This used for early domains only
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_domainID_t, am_DomainState_e>,
     std::tuple<>
-    > hookDomainStateChangeStubDispatcher(&RoutingControlObserverStub::hookDomainStateChange, "");
+    > RoutingControlObserverDBusStubAdapterInternal::hookDomainStateChangeStubDispatcher(&RoutingControlObserverStub::hookDomainStateChange, "");
 /**
  * is called when the timinginformation (delay) changed for a connection.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_connectionID_t, am_timeSync_t>,
     std::tuple<>
-    > hookTimingInformationChangedStubDispatcher(&RoutingControlObserverStub::hookTimingInformationChanged, "");
+    > RoutingControlObserverDBusStubAdapterInternal::hookTimingInformationChangedStubDispatcher(&RoutingControlObserverStub::hookTimingInformationChanged, "");
 /**
  * this function is used to send out all data that has been changed in an early
  *  state.
 (at)return E_OK on success, E_UNKNOWN on error
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_EarlyData_L>,
     std::tuple<>
-    > sendChangedDataStubDispatcher(&RoutingControlObserverStub::sendChangedData, "");
+    > RoutingControlObserverDBusStubAdapterInternal::sendChangedDataStubDispatcher(&RoutingControlObserverStub::sendChangedData, "");
 /**
  * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
  *  gatewayID is not valid.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
     std::tuple<am_Error_e>
-    > updateGatewayStubDispatcher(&RoutingControlObserverStub::updateGateway, "i");
+    > RoutingControlObserverDBusStubAdapterInternal::updateGatewayStubDispatcher(&RoutingControlObserverStub::updateGateway, "i");
 /**
  * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
  *  sinkID is not valid.
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
     std::tuple<am_Error_e>
-    > updateSinkStubDispatcher(&RoutingControlObserverStub::updateSink, "i");
+    > RoutingControlObserverDBusStubAdapterInternal::updateSinkStubDispatcher(&RoutingControlObserverStub::updateSink, "i");
 /**
  * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
  *  sourceID in the struct is not valid. 
-Please note that only the following
- *  data out of am_Source_s have effect when they are
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
  *  changed:
 sourceClassID,
 listSoundProperties,
@@ -816,56 +815,57 @@ listConnectionFormats,
  * 
 listMainSoundProperties
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
     std::tuple<am_Error_e>
-    > updateSourceStubDispatcher(&RoutingControlObserverStub::updateSource, "i");
+    > RoutingControlObserverDBusStubAdapterInternal::updateSourceStubDispatcher(&RoutingControlObserverStub::updateSource, "i");
 /**
  * acknowledges a asyncSetSinkVolumes
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_Volumes_L, am_Error_e>,
     std::tuple<>
-    > ackSetVolumesStubDispatcher(&RoutingControlObserverStub::ackSetVolumes, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetVolumesStubDispatcher(&RoutingControlObserverStub::ackSetVolumes, "");
 /**
  * The acknowledge of the SinkNotificationConfiguration
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_Error_e>,
     std::tuple<>
-    > ackSinkNotificationConfigurationStubDispatcher(&RoutingControlObserverStub::ackSinkNotificationConfiguration, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSinkNotificationConfigurationStubDispatcher(&RoutingControlObserverStub::ackSinkNotificationConfiguration, "");
 /**
  * The acknowledge of the SourceNotificationConfiguration
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_Handle_s, am_Error_e>,
     std::tuple<>
-    > ackSourceNotificationConfigurationStubDispatcher(&RoutingControlObserverStub::ackSourceNotificationConfiguration, "");
+    > RoutingControlObserverDBusStubAdapterInternal::ackSourceNotificationConfigurationStubDispatcher(&RoutingControlObserverStub::ackSourceNotificationConfiguration, "");
 /**
  * is called whenever a notified value needs to be send
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sinkID_t, am_NotificationPayload_s>,
     std::tuple<>
-    > hookSinkNotificationDataChangeStubDispatcher(&RoutingControlObserverStub::hookSinkNotificationDataChange, "");
+    > RoutingControlObserverDBusStubAdapterInternal::hookSinkNotificationDataChangeStubDispatcher(&RoutingControlObserverStub::hookSinkNotificationDataChange, "");
 /**
  * is called whenever a notified value needs to be send
  */
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<am_sourceID_t, am_NotificationPayload_s>,
     std::tuple<>
-    > hookSourceNotificationDataChangeStubDispatcher(&RoutingControlObserverStub::hookSourceNotificationDataChange, "");
-static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    > RoutingControlObserverDBusStubAdapterInternal::hookSourceNotificationDataChangeStubDispatcher(&RoutingControlObserverStub::hookSourceNotificationDataChange, "");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
     RoutingControlObserverStub,
     std::tuple<std::string>,
     std::tuple<>
-    > confirmRoutingRundownStubDispatcher(&RoutingControlObserverStub::confirmRoutingRundown, "");
+    > RoutingControlObserverDBusStubAdapterInternal::confirmRoutingRundownStubDispatcher(&RoutingControlObserverStub::confirmRoutingRundown, "");
+
 
 /**
  * This attribute signals to the clients the current routing state.
@@ -884,10 +884,14 @@ void RoutingControlObserverDBusStubAdapterInternal::fireRoutingReadyAttributeCha
 }
 
 
+
 const RoutingControlObserverDBusStubAdapterHelper::StubDispatcherTable& RoutingControlObserverDBusStubAdapterInternal::getStubDispatcherTable() {
     return stubDispatcherTable_;
 }
 
+const CommonAPI::DBus::StubAttributeTable& RoutingControlObserverDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
 
 RoutingControlObserverDBusStubAdapterInternal::RoutingControlObserverDBusStubAdapterInternal(
         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -921,92 +925,92 @@ RoutingControlObserverDBusStubAdapterInternal::RoutingControlObserverDBusStubAda
              *  should notify himself to this attribute in order to know the current state and
              *  act accordingly.
              */
-            { { "getRoutingReadyAttribute", "" }, &org::genivi::am::getRoutingReadyAttributeStubDispatcher }
+            { { "getRoutingReadyAttribute", "" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::getRoutingReadyAttributeStubDispatcher }
             ,
             /**
              * acknowledges a asyncConnect
              */
-            { { "ackConnect", "(iq)qi" }, &org::genivi::am::ackConnectStubDispatcher },
+            { { "ackConnect", "(iq)qi" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackConnectStubDispatcher },
             /**
              * acknowledges a asyncDisconnect
              */
-            { { "ackDisconnect", "(iq)qi" }, &org::genivi::am::ackDisconnectStubDispatcher },
+            { { "ackDisconnect", "(iq)qi" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackDisconnectStubDispatcher },
             /**
              * acknowledges a asyncsetSinkVolume
              */
-            { { "ackSetSinkVolumeChange", "(iq)ni" }, &org::genivi::am::ackSetSinkVolumeChangeStubDispatcher },
+            { { "ackSetSinkVolumeChange", "(iq)ni" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSinkVolumeChangeStubDispatcher },
             /**
              * acknowledges a asyncsetSourceVolume
              */
-            { { "ackSetSourceVolumeChange", "(iq)ni" }, &org::genivi::am::ackSetSourceVolumeChangeStubDispatcher },
+            { { "ackSetSourceVolumeChange", "(iq)ni" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSourceVolumeChangeStubDispatcher },
             /**
              * acknowlegde for asyncSetSourceState
              */
-            { { "ackSetSourceState", "(iq)i" }, &org::genivi::am::ackSetSourceStateStubDispatcher },
+            { { "ackSetSourceState", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSourceStateStubDispatcher },
             /**
              * acknowledges asyncSetSinkSoundProperties
              */
-            { { "ackSetSinkSoundProperties", "(iq)i" }, &org::genivi::am::ackSetSinkSoundPropertiesStubDispatcher },
+            { { "ackSetSinkSoundProperties", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSinkSoundPropertiesStubDispatcher },
             /**
              * acknowledges asyncSetSinkSoundProperty
              */
-            { { "ackSetSinkSoundProperty", "(iq)i" }, &org::genivi::am::ackSetSinkSoundPropertyStubDispatcher },
+            { { "ackSetSinkSoundProperty", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSinkSoundPropertyStubDispatcher },
             /**
              * acknowledges asyncSetSourceSoundProperties
              */
-            { { "ackSetSourceSoundProperties", "(iq)i" }, &org::genivi::am::ackSetSourceSoundPropertiesStubDispatcher },
+            { { "ackSetSourceSoundProperties", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSourceSoundPropertiesStubDispatcher },
             /**
              * acknowledges asyncSetSourceSoundProperty
              */
-            { { "ackSetSourceSoundProperty", "(iq)i" }, &org::genivi::am::ackSetSourceSoundPropertyStubDispatcher },
+            { { "ackSetSourceSoundProperty", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSourceSoundPropertyStubDispatcher },
             /**
              * acknowledges asyncCrossFade
              */
-            { { "ackCrossFading", "(iq)ii" }, &org::genivi::am::ackCrossFadingStubDispatcher },
+            { { "ackCrossFading", "(iq)ii" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackCrossFadingStubDispatcher },
             /**
              * acknowledges a volume tick. This can be used to display volumechanges during
              *  ramps
              */
-            { { "ackSourceVolumeTick", "(iq)qn" }, &org::genivi::am::ackSourceVolumeTickStubDispatcher },
+            { { "ackSourceVolumeTick", "(iq)qn" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSourceVolumeTickStubDispatcher },
             /**
              * acknowledges a volume tick. This can be used to display volumechanges during
              *  ramps
              */
-            { { "ackSinkVolumeTick", "(iq)qn" }, &org::genivi::am::ackSinkVolumeTickStubDispatcher },
+            { { "ackSinkVolumeTick", "(iq)qn" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSinkVolumeTickStubDispatcher },
             /**
              * This function returns the ID to the given domainName. If already a domain is
              *  registered with this name, it will return the corresponding ID, if not it will
              *  reserve an ID but not register the domain. The other parameters of the domain
              *  will be overwritten when the domain is registered.
-            (at)return E_OK on
-             *  success, E_UNKNOWN on error
+            (at)return E_OK on success,
+             *  E_UNKNOWN on error
              */
-            { { "peekDomain", "s" }, &org::genivi::am::peekDomainStubDispatcher },
+            { { "peekDomain", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekDomainStubDispatcher },
             /**
              * registers a domain
             (at)return E_OK on succes, E_ALREADY_EXISTENT if already
              *  registered E_UNKOWN on error
              */
-            { { "registerDomain", "(qsssbbi)ss" }, &org::genivi::am::registerDomainStubDispatcher },
+            { { "registerDomain", "(qsssbbi)ss" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerDomainStubDispatcher },
             /**
              * deregisters a domain. All sources, sinks, gateways and crossfaders from that
              *  domain will be removed as well.
             (at)return E_OK on succes, E_NON_EXISTENT if
              *  not found E_UNKOWN on error
              */
-            { { "deregisterDomain", "q" }, &org::genivi::am::deregisterDomainStubDispatcher },
+            { { "deregisterDomain", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterDomainStubDispatcher },
             /**
              * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
              *  registered E_UNKOWN on error
              */
-            { { "registerGateway", "(qsqqqqqaqaqab)" }, &org::genivi::am::registerGatewayStubDispatcher },
+            { { "registerGateway", "(qsqqqqqaqaqab)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerGatewayStubDispatcher },
             /**
              * deregisters a gateway. Also removes all sinks and sources of the controlling
              *  domain.
             (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
              *  error
              */
-            { { "deregisterGateway", "q" }, &org::genivi::am::deregisterGatewayStubDispatcher },
+            { { "deregisterGateway", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterGatewayStubDispatcher },
             /**
              * This function returns the ID to the given sinkName. If already a sink is
              *  registered with this name, it will return the corresponding ID, if not it will
@@ -1015,29 +1019,29 @@ RoutingControlObserverDBusStubAdapterInternal::RoutingControlObserverDBusStubAda
             (at)return E_OK on success,
              *  E_UNKNOWN on error
              */
-            { { "peekSink", "s" }, &org::genivi::am::peekSinkStubDispatcher },
+            { { "peekSink", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekSinkStubDispatcher },
             /**
              * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
              *  is copied to the gatewayInformation
             (at)return E_OK on succes,
              *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
              */
-            { { "registerSink", "(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))" }, &org::genivi::am::registerSinkStubDispatcher },
+            { { "registerSink", "(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerSinkStubDispatcher },
             /**
              * deregisters a sink.
             (at)return E_OK on succes, E_NON_EXISTENT if not found
              *  E_UNKOWN on error
              */
-            { { "deregisterSink", "q" }, &org::genivi::am::deregisterSinkStubDispatcher },
+            { { "deregisterSink", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterSinkStubDispatcher },
             /**
              * This function returns the ID to the given sourceName. If already a source is
              *  registered with this name, it will return the corresponding ID, if not it will
              *  reserve an ID but not register the source. The other parameters of the source
              *  will be overwritten when the source is registered.
-            (at)return E_OK on
-             *  success, E_UNKNOWN on error
+            (at)return E_OK on success,
+             *  E_UNKNOWN on error
              */
-            { { "peekSource", "s" }, &org::genivi::am::peekSourceStubDispatcher },
+            { { "peekSource", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekSourceStubDispatcher },
             /**
              * registers a source.  If the source is part of a gateway, the
              *  listconnectionFormats is copied to the gatewayInformation
@@ -1045,87 +1049,87 @@ RoutingControlObserverDBusStubAdapterInternal::RoutingControlObserverDBusStubAda
              *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
              *  already exists
              */
-            { { "registerSource", "(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))" }, &org::genivi::am::registerSourceStubDispatcher },
+            { { "registerSource", "(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerSourceStubDispatcher },
             /**
              * deregisters a source
             (at)return E_OK on succes, E_NON_EXISTENT if not found
              *  E_UNKOWN on error
              */
-            { { "deregisterSource", "q" }, &org::genivi::am::deregisterSourceStubDispatcher },
+            { { "deregisterSource", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterSourceStubDispatcher },
             /**
              * this function registers a crossfader.
             (at)return E_OK on succes,
              *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
              */
-            { { "registerCrossfader", "(qsqqqi)" }, &org::genivi::am::registerCrossfaderStubDispatcher },
+            { { "registerCrossfader", "(qsqqqi)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerCrossfaderStubDispatcher },
             /**
              * this function deregisters a crossfader. removes all sources and sinks assiated
              *  as well.
             (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
              *  error
              */
-            { { "deregisterCrossfader", "q" }, &org::genivi::am::deregisterCrossfaderStubDispatcher },
+            { { "deregisterCrossfader", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterCrossfaderStubDispatcher },
             /**
              * this function peeks a sourceclassID. It is used by the RoutingPlugins to
              *  determine the SinkClassIDs of a sinkClass.
             (at)return E_OK on succes,
              *  E_DATABASE_ERROR on error
              */
-            { { "peekSourceClassID", "s" }, &org::genivi::am::peekSourceClassIDStubDispatcher },
+            { { "peekSourceClassID", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekSourceClassIDStubDispatcher },
             /**
              * this function peeks a sourceclassID. It is used by the RoutingPlugins to
              *  determine the SinkClassIDs of a sinkClass.
             (at)return E_OK on succes,
              *  E_DATABASE_ERROR on error
              */
-            { { "peekSinkClassID", "s" }, &org::genivi::am::peekSinkClassIDStubDispatcher },
+            { { "peekSinkClassID", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekSinkClassIDStubDispatcher },
             /**
              * is called when a low level interrupt changes it status.
              */
-            { { "hookInterruptStatusChange", "qi" }, &org::genivi::am::hookInterruptStatusChangeStubDispatcher },
+            { { "hookInterruptStatusChange", "qi" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookInterruptStatusChangeStubDispatcher },
             /**
              * This hook is called when all elements from a domain are registered.
             Is used by
              *  the Controller to know when all expected domains are finally registered
              */
-            { { "hookDomainRegistrationComplete", "q" }, &org::genivi::am::hookDomainRegistrationCompleteStubDispatcher },
+            { { "hookDomainRegistrationComplete", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookDomainRegistrationCompleteStubDispatcher },
             /**
              * is called when a sink changes its availability
              */
-            { { "hookSinkAvailablityStatusChange", "q(iq)" }, &org::genivi::am::hookSinkAvailablityStatusChangeStubDispatcher },
+            { { "hookSinkAvailablityStatusChange", "q(iq)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookSinkAvailablityStatusChangeStubDispatcher },
             /**
              * is called when a source changes its availability
              */
-            { { "hookSourceAvailablityStatusChange", "q(iq)" }, &org::genivi::am::hookSourceAvailablityStatusChangeStubDispatcher },
+            { { "hookSourceAvailablityStatusChange", "q(iq)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookSourceAvailablityStatusChangeStubDispatcher },
             /**
              * is called when a domain changes its status. This used for early domains only
              */
-            { { "hookDomainStateChange", "qi" }, &org::genivi::am::hookDomainStateChangeStubDispatcher },
+            { { "hookDomainStateChange", "qi" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookDomainStateChangeStubDispatcher },
             /**
              * is called when the timinginformation (delay) changed for a connection.
              */
-            { { "hookTimingInformationChanged", "qn" }, &org::genivi::am::hookTimingInformationChangedStubDispatcher },
+            { { "hookTimingInformationChanged", "qn" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookTimingInformationChangedStubDispatcher },
             /**
              * this function is used to send out all data that has been changed in an early
              *  state.
             (at)return E_OK on success, E_UNKNOWN on error
              */
-            { { "sendChangedData", "a(i(yv)(yv))" }, &org::genivi::am::sendChangedDataStubDispatcher },
+            { { "sendChangedData", "a(i(yv)(yv))" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::sendChangedDataStubDispatcher },
             /**
              * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
              *  gatewayID is not valid.
              */
-            { { "updateGateway", "qaqaqab" }, &org::genivi::am::updateGatewayStubDispatcher },
+            { { "updateGateway", "qaqaqab" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::updateGatewayStubDispatcher },
             /**
              * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
              *  sinkID is not valid.
              */
-            { { "updateSink", "qqa(qn)aqa(qn)" }, &org::genivi::am::updateSinkStubDispatcher },
+            { { "updateSink", "qqa(qn)aqa(qn)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::updateSinkStubDispatcher },
             /**
              * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
              *  sourceID in the struct is not valid. 
-            Please note that only the following
-             *  data out of am_Source_s have effect when they are
+            Please note that only the following data
+             *  out of am_Source_s have effect when they are
              *  changed:
             sourceClassID,
             listSoundProperties,
@@ -1133,31 +1137,36 @@ RoutingControlObserverDBusStubAdapterInternal::RoutingControlObserverDBusStubAda
              * 
             listMainSoundProperties
              */
-            { { "updateSource", "qqa(qn)aqa(qn)" }, &org::genivi::am::updateSourceStubDispatcher },
+            { { "updateSource", "qqa(qn)aqa(qn)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::updateSourceStubDispatcher },
             /**
              * acknowledges a asyncSetSinkVolumes
              */
-            { { "ackSetVolumes", "(iq)a(i(yv)nqn)i" }, &org::genivi::am::ackSetVolumesStubDispatcher },
+            { { "ackSetVolumes", "(iq)a(i(yv)nqn)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetVolumesStubDispatcher },
             /**
              * The acknowledge of the SinkNotificationConfiguration
              */
-            { { "ackSinkNotificationConfiguration", "(iq)i" }, &org::genivi::am::ackSinkNotificationConfigurationStubDispatcher },
+            { { "ackSinkNotificationConfiguration", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSinkNotificationConfigurationStubDispatcher },
             /**
              * The acknowledge of the SourceNotificationConfiguration
              */
-            { { "ackSourceNotificationConfiguration", "(iq)i" }, &org::genivi::am::ackSourceNotificationConfigurationStubDispatcher },
+            { { "ackSourceNotificationConfiguration", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSourceNotificationConfigurationStubDispatcher },
             /**
              * is called whenever a notified value needs to be send
              */
-            { { "hookSinkNotificationDataChange", "q(qn)" }, &org::genivi::am::hookSinkNotificationDataChangeStubDispatcher },
+            { { "hookSinkNotificationDataChange", "q(qn)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookSinkNotificationDataChangeStubDispatcher },
             /**
              * is called whenever a notified value needs to be send
              */
-            { { "hookSourceNotificationDataChange", "q(qn)" }, &org::genivi::am::hookSourceNotificationDataChangeStubDispatcher },
-            { { "confirmRoutingRundown", "s" }, &org::genivi::am::confirmRoutingRundownStubDispatcher }
-            }) {
+            { { "hookSourceNotificationDataChange", "q(qn)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookSourceNotificationDataChangeStubDispatcher },
+            { { "confirmRoutingRundown", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::confirmRoutingRundownStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::getRoutingControlObserverInterfaceVersionStubDispatcher });
+}
 
-    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::getRoutingControlObserverInterfaceVersionStubDispatcher });
+const bool RoutingControlObserverDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
 }
 
 } // namespace am
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.h
index 144e86a..cf26863 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * Routing Receive sendInterface description.
@@ -33,7 +31,7 @@ namespace am {
 
 typedef CommonAPI::DBus::DBusStubAdapterHelper<RoutingControlObserverStub> RoutingControlObserverDBusStubAdapterHelper;
 
-class RoutingControlObserverDBusStubAdapterInternal: public RoutingControlObserverStubAdapter, public RoutingControlObserverDBusStubAdapterHelper {
+class RoutingControlObserverDBusStubAdapterInternal: public virtual RoutingControlObserverStubAdapter, public RoutingControlObserverDBusStubAdapterHelper {
  public:
     RoutingControlObserverDBusStubAdapterInternal(
             const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
@@ -46,6 +44,8 @@ class RoutingControlObserverDBusStubAdapterInternal: public RoutingControlObserv
 
     ~RoutingControlObserverDBusStubAdapterInternal();
 
+    virtual const bool hasFreedesktopProperties();
+
     /**
      * This attribute signals to the clients the current routing state.
     A client
@@ -57,15 +57,442 @@ class RoutingControlObserverDBusStubAdapterInternal: public RoutingControlObserv
 
 
     const RoutingControlObserverDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
 
     void deactivateManagedInstances();
 
 
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlObserverStub,
+        CommonAPI::Version
+        > getRoutingControlObserverInterfaceVersionStubDispatcher;
+
+/**
+ * This attribute signals to the clients the current routing state.
+A client
+ *  should notify himself to this attribute in order to know the current state and
+ *  act accordingly.
+ */
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlObserverStub,
+        am_RoutingReady_e
+        > getRoutingReadyAttributeStubDispatcher;
+
+
+/**
+ * acknowledges a asyncConnect
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
+    std::tuple<>
+    > ackConnectStubDispatcher;
+/**
+ * acknowledges a asyncDisconnect
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
+    std::tuple<>
+    > ackDisconnectStubDispatcher;
+/**
+ * acknowledges a asyncsetSinkVolume
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
+    std::tuple<>
+    > ackSetSinkVolumeChangeStubDispatcher;
+/**
+ * acknowledges a asyncsetSourceVolume
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
+    std::tuple<>
+    > ackSetSourceVolumeChangeStubDispatcher;
+/**
+ * acknowlegde for asyncSetSourceState
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSourceStateStubDispatcher;
+/**
+ * acknowledges asyncSetSinkSoundProperties
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSinkSoundPropertiesStubDispatcher;
+/**
+ * acknowledges asyncSetSinkSoundProperty
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSinkSoundPropertyStubDispatcher;
+/**
+ * acknowledges asyncSetSourceSoundProperties
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSourceSoundPropertiesStubDispatcher;
+/**
+ * acknowledges asyncSetSourceSoundProperty
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSourceSoundPropertyStubDispatcher;
+/**
+ * acknowledges asyncCrossFade
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_HotSink_e, am_Error_e>,
+    std::tuple<>
+    > ackCrossFadingStubDispatcher;
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_volume_t>,
+    std::tuple<>
+    > ackSourceVolumeTickStubDispatcher;
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_volume_t>,
+    std::tuple<>
+    > ackSinkVolumeTickStubDispatcher;
+/**
+ * This function returns the ID to the given domainName. If already a domain is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the domain. The other parameters of the domain
+ *  will be overwritten when the domain is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_domainID_t, am_Error_e>
+    > peekDomainStubDispatcher;
+/**
+ * registers a domain
+(at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Domain_s, std::string, std::string>,
+    std::tuple<am_domainID_t, am_Error_e>
+    > registerDomainStubDispatcher;
+/**
+ * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+ *  domain will be removed as well.
+(at)return E_OK on succes, E_NON_EXISTENT if
+ *  not found E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t>,
+    std::tuple<am_Error_e>
+    > deregisterDomainStubDispatcher;
+/**
+ * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Gateway_s>,
+    std::tuple<am_gatewayID_t, am_Error_e>
+    > registerGatewayStubDispatcher;
+/**
+ * deregisters a gateway. Also removes all sinks and sources of the controlling
+ *  domain.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_gatewayID_t>,
+    std::tuple<am_Error_e>
+    > deregisterGatewayStubDispatcher;
+/**
+ * This function returns the ID to the given sinkName. If already a sink is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the sink. The other parameters of the sink will
+ *  be overwritten when the sink is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sinkID_t, am_Error_e>
+    > peekSinkStubDispatcher;
+/**
+ * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+ *  is copied to the gatewayInformation
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Sink_s>,
+    std::tuple<am_sinkID_t, am_Error_e>
+    > registerSinkStubDispatcher;
+/**
+ * deregisters a sink.
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_Error_e>
+    > deregisterSinkStubDispatcher;
+/**
+ * This function returns the ID to the given sourceName. If already a source is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the source. The other parameters of the source
+ *  will be overwritten when the source is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sourceID_t, am_Error_e>
+    > peekSourceStubDispatcher;
+/**
+ * registers a source.  If the source is part of a gateway, the
+ *  listconnectionFormats is copied to the gatewayInformation
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+ *  already exists
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Source_s>,
+    std::tuple<am_sourceID_t, am_Error_e>
+    > registerSourceStubDispatcher;
+/**
+ * deregisters a source
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_Error_e>
+    > deregisterSourceStubDispatcher;
+/**
+ * this function registers a crossfader.
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Crossfader_s>,
+    std::tuple<am_crossfaderID_t, am_Error_e>
+    > registerCrossfaderStubDispatcher;
+/**
+ * this function deregisters a crossfader. removes all sources and sinks assiated
+ *  as well.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_crossfaderID_t>,
+    std::tuple<am_Error_e>
+    > deregisterCrossfaderStubDispatcher;
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sourceClass_t, am_Error_e>
+    > peekSourceClassIDStubDispatcher;
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sinkClass_t, am_Error_e>
+    > peekSinkClassIDStubDispatcher;
+/**
+ * is called when a low level interrupt changes it status.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_InterruptState_e>,
+    std::tuple<>
+    > hookInterruptStatusChangeStubDispatcher;
+/**
+ * This hook is called when all elements from a domain are registered.
+Is used by
+ *  the Controller to know when all expected domains are finally registered
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t>,
+    std::tuple<>
+    > hookDomainRegistrationCompleteStubDispatcher;
+/**
+ * is called when a sink changes its availability
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_Availability_s>,
+    std::tuple<>
+    > hookSinkAvailablityStatusChangeStubDispatcher;
+/**
+ * is called when a source changes its availability
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_Availability_s>,
+    std::tuple<>
+    > hookSourceAvailablityStatusChangeStubDispatcher;
+/**
+ * is called when a domain changes its status. This used for early domains only
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t, am_DomainState_e>,
+    std::tuple<>
+    > hookDomainStateChangeStubDispatcher;
+/**
+ * is called when the timinginformation (delay) changed for a connection.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_connectionID_t, am_timeSync_t>,
+    std::tuple<>
+    > hookTimingInformationChangedStubDispatcher;
+/**
+ * this function is used to send out all data that has been changed in an early
+ *  state.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_EarlyData_L>,
+    std::tuple<>
+    > sendChangedDataStubDispatcher;
+/**
+ * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  gatewayID is not valid.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+    std::tuple<am_Error_e>
+    > updateGatewayStubDispatcher;
+/**
+ * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sinkID is not valid.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+    std::tuple<am_Error_e>
+    > updateSinkStubDispatcher;
+/**
+ * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sourceID in the struct is not valid. 
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
+ *  changed:
+sourceClassID,
+listSoundProperties,
+listConnectionFormats,
+ * 
+listMainSoundProperties
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+    std::tuple<am_Error_e>
+    > updateSourceStubDispatcher;
+/**
+ * acknowledges a asyncSetSinkVolumes
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Volumes_L, am_Error_e>,
+    std::tuple<>
+    > ackSetVolumesStubDispatcher;
+/**
+ * The acknowledge of the SinkNotificationConfiguration
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSinkNotificationConfigurationStubDispatcher;
+/**
+ * The acknowledge of the SourceNotificationConfiguration
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSourceNotificationConfigurationStubDispatcher;
+/**
+ * is called whenever a notified value needs to be send
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_NotificationPayload_s>,
+    std::tuple<>
+    > hookSinkNotificationDataChangeStubDispatcher;
+/**
+ * is called whenever a notified value needs to be send
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_NotificationPayload_s>,
+    std::tuple<>
+    > hookSourceNotificationDataChangeStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<>
+    > confirmRoutingRundownStubDispatcher;
+
+
+
+
  protected:
     virtual const char* getMethodsDBusIntrospectionXmlData() const;
-    
-  private:
+
+ private:
     RoutingControlObserverDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
 };
 
 class RoutingControlObserverDBusStubAdapter: public RoutingControlObserverDBusStubAdapterInternal, public std::enable_shared_from_this<RoutingControlObserverDBusStubAdapter> {
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxy.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxy.h
index 998e8ae..8158450 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxy.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * Routing Receive sendInterface description.
@@ -325,8 +323,8 @@ public:
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the domain. The other parameters of the domain
      *  will be overwritten when the domain is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      * 
      * Calls peekDomain with synchronous semantics.
      * 
@@ -533,8 +531,8 @@ public:
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the source. The other parameters of the source
      *  will be overwritten when the source is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      * 
      * Calls peekSource with synchronous semantics.
      * 
@@ -920,8 +918,8 @@ public:
     /**
      * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
      *  sourceID in the struct is not valid. 
-    Please note that only the following
-     *  data out of am_Source_s have effect when they are
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
      *  changed:
     sourceClassID,
     listSoundProperties,
@@ -1127,6 +1125,12 @@ public:
     std::shared_ptr<RoutingControlObserverProxyBase> delegate_;
 };
 
+#ifdef WIN32
+    typedef RoutingControlObserverProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> RoutingControlObserverProxyDefault;
+#else
+    typedef RoutingControlObserverProxy<> RoutingControlObserverProxyDefault;
+#endif
+
 namespace RoutingControlObserverExtensions {
     /**
      * This attribute signals to the clients the current routing state.
@@ -1141,6 +1145,9 @@ namespace RoutingControlObserverExtensions {
     
         static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<RoutingControlObserverProxyBase::RoutingReadyAttribute>, extension_type>::value,
                       "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        RoutingReadyAttributeExtension() {}
+    #endif
     
         RoutingReadyAttributeExtension(RoutingControlObserverProxyBase& proxy): attributeExtension_(proxy.getRoutingReadyAttribute()) {
         }
@@ -1160,8 +1167,8 @@ namespace RoutingControlObserverExtensions {
 //
 template <typename ... _AttributeExtensions>
 RoutingControlObserverProxy<_AttributeExtensions...>::RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
-        delegate_(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)),
-        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)))... {
+        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)) {
 }
 
 template <typename ... _AttributeExtensions>
@@ -1319,8 +1326,8 @@ std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensi
  *  registered with this name, it will return the corresponding ID, if not it will
  *  reserve an ID but not register the domain. The other parameters of the domain
  *  will be overwritten when the domain is registered.
-(at)return E_OK on
- *  success, E_UNKNOWN on error
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
  */
 template <typename ... _AttributeExtensions>
 void RoutingControlObserverProxy<_AttributeExtensions...>::peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
@@ -1439,8 +1446,8 @@ std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensi
  *  registered with this name, it will return the corresponding ID, if not it will
  *  reserve an ID but not register the source. The other parameters of the source
  *  will be overwritten when the source is registered.
-(at)return E_OK on
- *  success, E_UNKNOWN on error
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
  */
 template <typename ... _AttributeExtensions>
 void RoutingControlObserverProxy<_AttributeExtensions...>::peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
@@ -1657,8 +1664,8 @@ std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensi
 /**
  * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
  *  sourceID in the struct is not valid. 
-Please note that only the following
- *  data out of am_Source_s have effect when they are
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
  *  changed:
 sourceClassID,
 listSoundProperties,
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxyBase.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxyBase.h
index fa80989..3a8f470 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxyBase.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxyBase.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * Routing Receive sendInterface description.
@@ -165,8 +163,8 @@ class RoutingControlObserverProxyBase: virtual public CommonAPI::Proxy {
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the domain. The other parameters of the domain
      *  will be overwritten when the domain is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      */
     virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) = 0;
     virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) = 0;
@@ -229,8 +227,8 @@ class RoutingControlObserverProxyBase: virtual public CommonAPI::Proxy {
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the source. The other parameters of the source
      *  will be overwritten when the source is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      */
     virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) = 0;
     virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) = 0;
@@ -335,8 +333,8 @@ class RoutingControlObserverProxyBase: virtual public CommonAPI::Proxy {
     /**
      * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
      *  sourceID in the struct is not valid. 
-    Please note that only the following
-     *  data out of am_Source_s have effect when they are
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
      *  changed:
     sourceClassID,
     listSoundProperties,
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStub.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStub.h
index eb61414..b01b1bd 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStub.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStub.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * Routing Receive sendInterface description.
@@ -87,7 +85,7 @@ class RoutingControlObserverStubRemoteEvent {
  * This class and the one above are the ones an application developer needs to have
  * a look at if he wants to implement a service.
  */
-class RoutingControlObserverStub : public virtual CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent> {
+class RoutingControlObserverStub: public virtual CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent> {
 public:
     virtual ~RoutingControlObserverStub() { }
     virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
@@ -168,8 +166,8 @@ public:
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the domain. The other parameters of the domain
      *  will be overwritten when the domain is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      */
     /// This is the method that will be called on remote calls on the method peekDomain.
     virtual void peekDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_domainID_t& domainID, am_Error_e& error) = 0;
@@ -232,8 +230,8 @@ public:
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the source. The other parameters of the source
      *  will be overwritten when the source is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      */
     /// This is the method that will be called on remote calls on the method peekSource.
     virtual void peekSource(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceID_t& sourceID, am_Error_e& error) = 0;
@@ -338,8 +336,8 @@ public:
     /**
      * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
      *  sourceID in the struct is not valid. 
-    Please note that only the following
-     *  data out of am_Source_s have effect when they are
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
      *  changed:
     sourceClassID,
     listSoundProperties,
@@ -380,6 +378,8 @@ public:
     using CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::initStubAdapter;
     typedef CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::StubAdapterType StubAdapterType;
     typedef CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef RoutingControlObserverStubRemoteEvent RemoteEventType;
+    typedef RoutingControlObserver StubInterface;
 };
 
 } // namespace am
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.cpp
index 46d10f7..fe41554 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.cpp
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include <org/genivi/am/RoutingControlObserverStubDefault.h>
 
@@ -37,7 +35,7 @@ const am_RoutingReady_e& RoutingControlObserverStubDefault::getRoutingReadyAttri
 
 void RoutingControlObserverStubDefault::setRoutingReadyAttribute(am_RoutingReady_e value) {
     const bool valueChanged = trySetRoutingReadyAttribute(std::move(value));
-    if (valueChanged) {
+    if (valueChanged && stubAdapter_ != NULL) {
         stubAdapter_->fireRoutingReadyAttributeChanged(routingReadyAttributeValue_);
     }
 }
@@ -196,8 +194,8 @@ void RoutingControlObserverStubDefault::ackSinkVolumeTick(am_Handle_s handle, am
  *  registered with this name, it will return the corresponding ID, if not it will
  *  reserve an ID but not register the domain. The other parameters of the domain
  *  will be overwritten when the domain is registered.
-(at)return E_OK on
- *  success, E_UNKNOWN on error
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
  */
 void RoutingControlObserverStubDefault::peekDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_domainID_t& domainID, am_Error_e& error) {
     // Call old style methods in default 
@@ -308,8 +306,8 @@ void RoutingControlObserverStubDefault::deregisterSink(am_sinkID_t sinkID, am_Er
  *  registered with this name, it will return the corresponding ID, if not it will
  *  reserve an ID but not register the source. The other parameters of the source
  *  will be overwritten when the source is registered.
-(at)return E_OK on
- *  success, E_UNKNOWN on error
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
  */
 void RoutingControlObserverStubDefault::peekSource(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceID_t& sourceID, am_Error_e& error) {
     // Call old style methods in default 
@@ -510,8 +508,8 @@ void RoutingControlObserverStubDefault::updateSink(am_sinkID_t sinkID, am_sinkCl
 /**
  * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
  *  sourceID in the struct is not valid. 
-Please note that only the following
- *  data out of am_Source_s have effect when they are
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
  *  changed:
 sourceClassID,
 listSoundProperties,
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.h
index 0d19077..034a727 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * Routing Receive sendInterface description.
@@ -123,8 +121,8 @@ public:
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the domain. The other parameters of the domain
      *  will be overwritten when the domain is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      */
     virtual void peekDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_domainID_t& domainID, am_Error_e& error);
     virtual void peekDomain(std::string name, am_domainID_t& domainID, am_Error_e& error);
@@ -195,8 +193,8 @@ public:
      *  registered with this name, it will return the corresponding ID, if not it will
      *  reserve an ID but not register the source. The other parameters of the source
      *  will be overwritten when the source is registered.
-    (at)return E_OK on
-     *  success, E_UNKNOWN on error
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
      */
     virtual void peekSource(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceID_t& sourceID, am_Error_e& error);
     virtual void peekSource(std::string name, am_sourceID_t& sourceID, am_Error_e& error);
@@ -317,8 +315,8 @@ public:
     /**
      * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
      *  sourceID in the struct is not valid. 
-    Please note that only the following
-     *  data out of am_Source_s have effect when they are
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
      *  changed:
     sourceClassID,
     listSoundProperties,
@@ -374,8 +372,7 @@ protected:
      */
     virtual bool trySetRoutingReadyAttribute(am_RoutingReady_e value);
     virtual bool validateRoutingReadyAttributeRequestedValue(const am_RoutingReady_e& value);
-private:
-    class RemoteEventHandler: public RoutingControlObserverStubRemoteEvent {
+    class RemoteEventHandler: public virtual RoutingControlObserverStubRemoteEvent {
      public:
         RemoteEventHandler(RoutingControlObserverStubDefault* defaultStub);
 
@@ -390,8 +387,8 @@ private:
      private:
         RoutingControlObserverStubDefault* defaultStub_;
     };
-
-    RemoteEventHandler remoteEventHandler_;
+private:
+    RoutingControlObserverStubDefault::RemoteEventHandler remoteEventHandler_;
 
     /**
      * This attribute signals to the clients the current routing state.
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxy.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxy.h
index 4cc1ba0..a828096 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxy.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxy.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * This class implements everything from Audiomanager -&gt; RoutingAdapter
@@ -67,7 +65,7 @@ public:
     /**
      * connects a source to a sink
     (at)return E_OK on success, E_UNKNOWN on error,
-     *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
      * 
      * Calls asyncConnect with synchronous semantics.
      * 
@@ -192,8 +190,8 @@ public:
     virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback);
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      * 
      * Calls asyncSetSinkSoundProperties with synchronous semantics.
      * 
@@ -216,8 +214,8 @@ public:
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback);
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      * 
      * Calls asyncSetSinkSoundProperty with synchronous semantics.
      * 
@@ -443,14 +441,20 @@ public:
     std::shared_ptr<RoutingControlProxyBase> delegate_;
 };
 
+#ifdef WIN32
+    typedef RoutingControlProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> RoutingControlProxyDefault;
+#else
+    typedef RoutingControlProxy<> RoutingControlProxyDefault;
+#endif
+
 
 //
 // RoutingControlProxy Implementation
 //
 template <typename ... _AttributeExtensions>
 RoutingControlProxy<_AttributeExtensions...>::RoutingControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
-        delegate_(std::dynamic_pointer_cast<RoutingControlProxyBase>(delegate)),
-        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlProxyBase>(delegate)))... {
+        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<RoutingControlProxyBase>(delegate)) {
 }
 
 template <typename ... _AttributeExtensions>
@@ -474,7 +478,7 @@ std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>:
 /**
  * connects a source to a sink
 (at)return E_OK on success, E_UNKNOWN on error,
- *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
  */
 template <typename ... _AttributeExtensions>
 void RoutingControlProxy<_AttributeExtensions...>::asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus) {
@@ -549,8 +553,8 @@ std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>:
 }
 /**
  * this function sets the sinksoundproperty.
-(at)return E_OK on success,
- *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
 template <typename ... _AttributeExtensions>
 void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) {
@@ -563,8 +567,8 @@ std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>:
 }
 /**
  * this function sets the sinksoundproperty.
-(at)return E_OK on success,
- *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
 template <typename ... _AttributeExtensions>
 void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) {
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxyBase.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxyBase.h
index 75bba47..047dee2 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxyBase.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxyBase.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * This class implements everything from Audiomanager -&gt; RoutingAdapter
@@ -70,7 +68,7 @@ class RoutingControlProxyBase: virtual public CommonAPI::Proxy {
     /**
      * connects a source to a sink
     (at)return E_OK on success, E_UNKNOWN on error,
-     *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
      */
     virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, AsyncConnectAsyncCallback callback) = 0;
@@ -110,15 +108,15 @@ class RoutingControlProxyBase: virtual public CommonAPI::Proxy {
     virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback) = 0;
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      */
     virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback) = 0;
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      */
     virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback) = 0;
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStub.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStub.h
index 5303589..853b179 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStub.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStub.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * This class implements everything from Audiomanager -&gt; RoutingAdapter
@@ -83,7 +81,7 @@ class RoutingControlStubRemoteEvent {
  * This class and the one above are the ones an application developer needs to have
  * a look at if he wants to implement a service.
  */
-class RoutingControlStub : public virtual CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent> {
+class RoutingControlStub: public virtual CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent> {
 public:
     virtual ~RoutingControlStub() { }
     virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
@@ -99,7 +97,7 @@ public:
     /**
      * connects a source to a sink
     (at)return E_OK on success, E_UNKNOWN on error,
-     *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
      */
     /// This is the method that will be called on remote calls on the method asyncConnect.
     virtual void asyncConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat) = 0;
@@ -139,15 +137,15 @@ public:
     virtual void asyncSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SourceState_e state) = 0;
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      */
     /// This is the method that will be called on remote calls on the method asyncSetSinkSoundProperties.
     virtual void asyncSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties) = 0;
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      */
     /// This is the method that will be called on remote calls on the method asyncSetSinkSoundProperty.
     virtual void asyncSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty) = 0;
@@ -189,6 +187,8 @@ public:
     using CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent>::initStubAdapter;
     typedef CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent>::StubAdapterType StubAdapterType;
     typedef CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef RoutingControlStubRemoteEvent RemoteEventType;
+    typedef RoutingControl StubInterface;
 };
 
 } // namespace am
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.cpp
index 77e34e4..58a3918 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.cpp
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.cpp
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 #include <org/genivi/am/RoutingControlStubDefault.h>
 
@@ -44,7 +42,7 @@ void RoutingControlStubDefault::asyncAbort(am_Handle_s handle) {
 /**
  * connects a source to a sink
 (at)return E_OK on success, E_UNKNOWN on error,
- *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
  */
 void RoutingControlStubDefault::asyncConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat) {
     // Call old style methods in default 
@@ -114,8 +112,8 @@ void RoutingControlStubDefault::asyncSetSourceState(am_Handle_s handle, am_sourc
 
 /**
  * this function sets the sinksoundproperty.
-(at)return E_OK on success,
- *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
 void RoutingControlStubDefault::asyncSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties) {
     // Call old style methods in default 
@@ -127,8 +125,8 @@ void RoutingControlStubDefault::asyncSetSinkSoundProperties(am_Handle_s handle,
 
 /**
  * this function sets the sinksoundproperty.
-(at)return E_OK on success,
- *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
  */
 void RoutingControlStubDefault::asyncSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty) {
     // Call old style methods in default 
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.h
index f411112..e53197e 100644
--- a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.h
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.h
@@ -1,11 +1,9 @@
 /*
 * This file was generated by the CommonAPI Generators.
-* Used org.genivi.commonapi.core 2.1.5.201312121915.
-* Used org.franca.core 0.8.11.201401091023.
+* Used org.genivi.commonapi.core 2.1.6.v20140815.
+* Used org.franca.core 0.8.10.201309262002.
 *
-* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
-* If a copy of the MPL was not distributed with this file, You can obtain one at
-* http://mozilla.org/MPL/2.0/.
+* 
 */
 /**
  * This class implements everything from Audiomanager -&gt; RoutingAdapter
@@ -52,7 +50,7 @@ public:
     /**
      * connects a source to a sink
     (at)return E_OK on success, E_UNKNOWN on error,
-     *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
      */
     virtual void asyncConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat);
     virtual void asyncConnect(am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat);
@@ -97,16 +95,16 @@ public:
 
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      */
     virtual void asyncSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties);
     virtual void asyncSetSinkSoundProperties(am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties);
 
     /**
      * this function sets the sinksoundproperty.
-    (at)return E_OK on success,
-     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
      */
     virtual void asyncSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty);
     virtual void asyncSetSinkSoundProperty(am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty);
@@ -156,8 +154,7 @@ public:
 
 
 protected:
-private:
-    class RemoteEventHandler: public RoutingControlStubRemoteEvent {
+    class RemoteEventHandler: public virtual RoutingControlStubRemoteEvent {
      public:
         RemoteEventHandler(RoutingControlStubDefault* defaultStub);
 
@@ -165,8 +162,8 @@ private:
      private:
         RoutingControlStubDefault* defaultStub_;
     };
-
-    RemoteEventHandler remoteEventHandler_;
+private:
+    RoutingControlStubDefault::RemoteEventHandler remoteEventHandler_;
 
 
     CommonAPI::Version interfaceVersion_;
-- 
2.0.4

